<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>為什麼想寫部落格?</title>
    <url>/2020/10/27/%E7%82%BA%E4%BB%80%E9%BA%BC%E6%83%B3%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<p>不知不覺就記錄了10篇文章，以往都是記錄在其他的線上筆記居多，也沒有整理過，看到可能重要的就先寫進再說。</p>
<p>雖然線上筆記服務也是可以公開分享，Medium也可以寫文章，但總覺得它對於程式碼區塊的顏色看不順眼，HackMD則變成了快速筆記用，最終還是採取建立一個技術性質的部落格。</p>
<p>而寫文的目的是重新記錄自己學過的技能，不管它是否能幫我轉職，取之於社會用之於社會，於是這個部落格就誕生了，謝謝參考來源的作者不吝分享經驗。</p>
]]></content>
      <categories>
        <category>閒聊</category>
      </categories>
  </entry>
  <entry>
    <title>記錄自己的成長，那怕是1%也好</title>
    <url>/2020/10/16/%E8%A8%98%E9%8C%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%88%90%E9%95%B7%EF%BC%8C%E9%82%A3%E6%80%95%E6%98%AF1-%E4%B9%9F%E5%A5%BD/</url>
    <content><![CDATA[<p>利用 Hexo寫技術部落格，那怕是第一篇，或者只有一篇，只怕自己停佇不前。</p>
]]></content>
      <categories>
        <category>閒聊</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo教學(六) 文章標籤與分類</title>
    <url>/2020/10/26/hexo%E6%95%99%E5%AD%B8/Hexo%E6%95%99%E5%AD%B8(%E5%85%AD)%E6%96%87%E7%AB%A0%E6%A8%99%E7%B1%A4%E8%88%87%E5%88%86%E9%A1%9E/</url>
    <content><![CDATA[<p>先前我們學到如何新增一篇文章，這篇會說明如何將文章上標籤與分類管理。</p>
<h2 id="建立分類"><a href="#建立分類" class="headerlink" title="建立分類"></a>建立分類</h2><ol>
<li>輸入 <code>hexo new page &#39;categories&#39;</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source中會看到 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories</li>
<li>修改 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories中的 index.md檔案，插入 <code>type: &quot;categories&quot;</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-22 11:16:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>在 _post內的其中一份檔案插入 <code>categories: hexo教學</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章標題</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>重新產生靜態檔案，可以在導覽列看到多了一個分類分頁</li>
</ol>
<h2 id="建立標籤"><a href="#建立標籤" class="headerlink" title="建立標籤"></a>建立標籤</h2><p>與分類的步驟一樣，但內容改變。</p>
<ol>
<li>輸入 <code>hexo new page &#39;tags&#39;</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source中會看到 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories</li>
<li>修改 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> tags index.md檔案，插入 <code>type: &quot;tags&quot;</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-22 11:16:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>在 _post內的其中一份檔案插入 <code>categories: hexo教學</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章標題</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
若需要多個標籤，可以這樣輸入<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">教學文</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>重新產生靜態檔案，可以在導覽列看到多了一個標籤分頁</li>
</ol>
<p>若沒看到分頁出現，可能是 Next主題的設定沒有開啟，可以在 Next主題的設定檔中開啟，路徑為 themes\next_config.yml，</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || fa fa-home</span><br><span class="line">  <span class="meta">#about: /about/ || fa fa-user</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || fa fa-tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || fa fa-th</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="meta"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="meta"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="meta"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(一) 使用 Hexo寫部落格</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%B8%80)%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E4%BD%BF%E7%94%A8Hexo%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="為什麼要使用-Hexo寫部落格"><a href="#為什麼要使用-Hexo寫部落格" class="headerlink" title="為什麼要使用 Hexo寫部落格?"></a>為什麼要使用 Hexo寫部落格?</h2><p>現在有很多線上服務都能當成部落格，不管寫在 github、medium或者 wordpress等等，同樣是寫文章，心得也好，技術文也罷，學著使用 markdown寫文，最起碼自己的電腦有初始檔案，不怕線上服務突然關閉或者改變使用條款，而且只要有網頁伺服器，就能發布自己的部落格。</p>
<h2 id="教學連結"><a href="#教學連結" class="headerlink" title="教學連結"></a>教學連結</h2><p>後續 hexo教學會說明這些主題並建立連結 :</p>
<ul>
<li>環境建立與安裝</li>
<li>匯入主題 (themes)</li>
<li>部屬到網頁 (使用 github page)</li>
<li>分類與標籤</li>
<li>Next主題相關設定 - 開啟數學符號以及更改字體</li>
</ul>
<h2 id="撰寫工具與線上服務"><a href="#撰寫工具與線上服務" class="headerlink" title="撰寫工具與線上服務"></a>撰寫工具與線上服務</h2><p>我們會使用到的軟體或服務如下，可以先點連結下載安裝或者先建立帳號</p>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a> <ul>
<li>程式編輯器，我們會使用 VScode來編輯  hexo的資源</li>
</ul>
</li>
<li><a href="https://nodejs.org/en/">node.js</a><ul>
<li>後續安裝 hexo環境會用到，LTS是穩定的版本，Current是最新的，推薦使用 <strong>LTS版本</strong></li>
</ul>
</li>
<li><a href="https://github.com/">github.com</a><ul>
<li>程式碼版控，其中一項服務可以用來發布 hexo</li>
</ul>
</li>
<li><a href="https://hackmd.io/">HackMD</a><ul>
<li>線上筆記之一， hexo的撰寫方式為 markdown，使用 HackMD的服務可以快速編輯與即時預覽，不怕文章編輯到一半當掉。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(三) 主題匯入</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%B8%89)%E4%B8%BB%E9%A1%8C%E5%8C%AF%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Hexo檔案結構"><a href="#Hexo檔案結構" class="headerlink" title="Ｈexo檔案結構"></a>Ｈexo檔案結構</h2><p>Hexo裡面會有一些內層資料夾以及一些單一檔案，敘述如下 :<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> node_modules $\rightarrow$ node.js套件資源包，通常此資料夾容量很大<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> public $\rightarrow$ 經由 <code>hexo generate</code> 指令所發布的靜態檔案都在這<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> scaffolds $\rightarrow$ 當我們新增一篇文章或頁面時，會根據這裡的模板檔案進行初始化<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source $\rightarrow$ 新增的文章與頁面都會在這<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _posts $\rightarrow$ 存放 <code>hexo new post/draft/page &#39;文章標題&#39;</code> 指令新增的文章<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> themes $\rightarrow$ hexo主題都會放在這裡<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> landscape  $\rightarrow$ 預設主題<br>├─ _config.yml  $\rightarrow$ hexo的設定檔，稍後會到這裡設定<br>├─ .gitignore $\rightarrow$ 會被 git忽略的資料夾或檔案在這裡設定<br>├─ package.json $\rightarrow$ 與 npm相關，管理會用到的套件版本，可修改版本來使用<br>└─  package-lock.json $\rightarrow$ 與 npm相關，此為自動產生，不必修改</p>
<p>備註 : 可以在  _posts 內增加資料夾進行文章分類</p>
<h2 id="匯入主題"><a href="#匯入主題" class="headerlink" title="匯入主題"></a>匯入主題</h2><p>官方預設的主題會放在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> themes中，主題名稱是 landscape，而 Hexo的主題可以自行製作，也可以到<a href="https://hexo.io/themes/">這邊</a>尋找喜歡的，這裡分享如以下 :</p>
<ul>
<li>hueman<ul>
<li><code>git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman</code></li>
</ul>
</li>
<li>NexT<ul>
<li><a href="https://github.com/next-theme/hexo-theme-next.git">版本 v8 </a></li>
<li><code>git clone https://github.com/next-theme/hexo-theme-next.git themes/next</code></li>
</ul>
</li>
</ul>
<p>那麼要如何將主題匯入呢?<br>上面那串指令就是將主題從網路上下載一份回來，並存放在指定的位置，將它簡化就是 <code>git clone 主題存放網址 hexo指定的資料夾位置</code>，記得要在建立好的<code>桌面\新增資料夾\hexoblog</code>中輸入指令，路徑位置為舉例，請根據有上述那些資料夾的 hexo位置輸入。</p>
<h3 id="NexT主題設定"><a href="#NexT主題設定" class="headerlink" title="NexT主題設定"></a>NexT主題設定</h3><p>由於自己選擇了 NexT主題匯入，<a href="https://hsuan777.github.io/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8Next%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A/">這邊</a>有 NexT的設定與說明。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10238330">Ray - (4) 試著學 Hexo - 認識 Hexo 目錄結構</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10246631">Ray - (17) 試著學 Hexo - NexT 主題篇 - NexT</a></li>
<li><a href="https://ed521.github.io/2020/05/hexo-folder-theme/">瑪利歐 - Hexo 資料夾/檔案架構、佈景主題修改介紹</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(二) 環境建立與安裝 hexo</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%BA%8C)%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E5%AE%89%E8%A3%9Dhexo/</url>
    <content><![CDATA[<h2 id="基礎環境建立"><a href="#基礎環境建立" class="headerlink" title="基礎環境建立"></a>基礎環境建立</h2><ol>
<li>開啟 VScode後，按下快捷鍵 <code>ctrl+~</code>，會打開終端機</li>
<li>輸入 <code>node -v</code><ul>
<li>確認 node.js，若成功會出現版本編號</li>
</ul>
</li>
<li>輸入 <code>npm -v</code> <ul>
<li>確認 npm，若成功會出現版本編號</li>
</ul>
</li>
<li>輸入 <code>npm install -g hexo-cli</code><ul>
<li>正式安裝 hexo</li>
</ul>
</li>
</ol>
<h3 id="node-js與-npm"><a href="#node-js與-npm" class="headerlink" title="node.js與 npm"></a>node.js與 npm</h3><p>自己對它們的了解， node.js是一個執行 JavaScript的環境，如同要運作 python時必須安裝 python的執行檔，npm則是一個線上的套件資源庫，可以輸入指令 <code>npm install 套件名稱</code> 來安裝額外套件，可以在網路上搜尋這兩個<a href="https://www.google.com/search?ei=j06SX_bNB5G9mAXOkoSgBw&q=node.js+npm&oq=node.js+npm&gs_lcp=CgZwc3ktYWIQAzICCAAyAggAMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjoFCAAQzQJQzGFYu25glHJoAHAAeACAAYoBiAHcApIBAzMuMZgBAKABAaoBB2d3cy13aXrAAQE&sclient=psy-ab&ved=0ahUKEwi20d2548nsAhWRHqYKHU4JAXQQ4dUDCA0&uact=5">關鍵字</a>，會有更多開發者的說明。</p>
<h2 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h2><p>上一階段已安裝完 hexo所需的基礎環境，接著要在電腦中新增一個空的資料夾來存放 hexo的檔案。</p>
<ol>
<li>新增資料夾<ul>
<li>可以直接在桌面上新增一個資料夾，接著將它拖曳至 VScode，終端機的路徑就會是該資料夾的路徑了</li>
<li>或者輸入終端機指令來新增一個空的資料夾並進入該資料夾中</li>
</ul>
</li>
<li>輸入 <code>hexo init 自訂部落格名稱</code><ul>
<li>為了方便說明自訂部落格名稱簡化為 hexoblog</li>
<li>確認終端機路徑已在新建立的空資料夾中，我們要在這個資料夾中下載 hexo的初始檔案，也就是 hexo的初始化</li>
<li>資料夾名稱可以跟部落格名稱不同，可以在 hexo的設定檔中更改部落格名稱</li>
<li>若只輸入 <code>hexo init</code>，很可能會遇到安裝錯誤</li>
</ul>
</li>
<li>確認 hexo初始資源<ul>
<li>此時資料夾結構應該會是 <code>桌面\新增資料夾\hexobolg</code></li>
<li>輸入 <code>cd hexobolg</code>，路徑會從 <code>桌面桌面\新增資料夾</code> 變更為 <code>桌面桌面\新增資料夾\hexobolg</code></li>
<li>可以在 VScode的左邊檔案視窗檢查，確認 hexobolg的資料夾已有 hexo的初始相關檔案</li>
</ul>
</li>
</ol>
<p>舉個範例，若在桌面上新增了一個資料夾，那麼最終資料夾結構應該會是 <code>桌面\新增資料夾\hexoblog</code></p>
<h2 id="修改基礎設定"><a href="#修改基礎設定" class="headerlink" title="修改基礎設定"></a>修改基礎設定</h2><p>剛下載好的 hexo有些設定是預設的，所以我們要修改成自己的。<br>找到 <code>hexoblog\_config.yml</code>這隻檔案，可以先修改以下資訊</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attribute">title</span>: Help One Percent</span><br><span class="line"><span class="attribute">subtitle</span>: &#x27;遺忘x回想x自動化&#x27;</span><br><span class="line"><span class="attribute">description</span>: &#x27;哪怕是1%也好，只怕自己停佇不前&#x27;</span><br><span class="line"><span class="attribute">keywords</span>: 前端,CSS,JavaScript,Vue.js,git,演算法入門</span><br><span class="line"><span class="attribute">author</span>: Vic</span><br><span class="line"><span class="attribute">language</span>: zh-TW</span><br><span class="line"><span class="attribute">timezone</span>: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="啟動-hexo"><a href="#啟動-hexo" class="headerlink" title="啟動 hexo"></a>啟動 hexo</h2><p>接下來，我們可以先使用預設主題模擬上線情況。</p>
<ol>
<li>輸入 <code>hexo generate</code><ul>
<li>會產生靜態檔案</li>
</ul>
</li>
<li>輸入 <code>hexo server</code><ul>
<li>啟動 hexo內建的模擬網頁伺服器</li>
</ul>
</li>
<li>在網址列輸入提供的網址，預設會是 <code>http://localhost:4000</code></li>
</ol>
<p>若成功看到預設主題以及第一篇文章標題 “Hello World”，恭喜你已經完成一半了! </p>
<p>接下來我們要新增一篇文章並調整主題以及其他設定。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10236936">Ray - (3)試著學 Hexo - 如何安裝 Hexo</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10238330">Ray - (4)試著學 Hexo - 認識 Hexo 目錄結構</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(五) 部署文章至 Github Page</title>
    <url>/2020/10/26/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%BA%94)%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0%E8%87%B3%20Github%20Page/</url>
    <content><![CDATA[<h2 id="建立-github資料庫"><a href="#建立-github資料庫" class="headerlink" title="建立 github資料庫"></a>建立 github資料庫</h2><p>登入 github.com後，新增一個資料庫做為 hexo的儲存空間，我們會使用這個資料庫發布部落格。</p>
<ol>
<li>右上方點擊 New repository</li>
<li>在 Repository name欄位中輸入 <code>你的github帳號.github.io</code></li>
<li>選擇 Public</li>
<li>點擊 Creat repository</li>
<li>點擊此資料庫的 <strong>Setting</strong></li>
<li>在 Setting的頁面中找到名為 GitHub Pages的標題</li>
<li>在 GitHub Pages的選項中，找到子標題 Source，將第一個選項改為 master</li>
<li>選擇 master後，會發現上面一則通知，它會是<br>Your site is published at https://你的github帳號.github.io</li>
</ol>
<h2 id="修改-hexo設定檔"><a href="#修改-hexo設定檔" class="headerlink" title="修改 hexo設定檔"></a>修改 hexo設定檔</h2><p>建立好 github的資料庫後，接著我們回到 hexo底下的 <code>_config.yml</code>，我們要修改發布時會用到的資訊。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line">url: https:<span class="regexp">//</span>你的github帳號.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:<span class="regexp">//gi</span>thub.com<span class="regexp">/你的github帳號/</span>你的github帳號.github.io.git </span><br><span class="line">  branch: master </span><br><span class="line">  message: <span class="string">&#x27;hexoblog&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="部屬-Deploy"><a href="#部屬-Deploy" class="headerlink" title="部屬 (Deploy)"></a>部屬 (Deploy)</h2><p>完成上述兩個部分後，讓我們重新產生 hexo的靜態檔案，就能將寫好的文章上傳了。<br>這裡還需要再輸入一個指令，<code>npm install --save hexo-deployer-git</code>，這樣才能將 hexo一鍵部屬到 github上。</p>
<ol>
<li>輸入 <code>hexo clean</code>，可縮寫 <code>hexo cl</code></li>
<li>輸入 <code>hexo generate</code>，可縮寫 <code>hexo g</code></li>
<li>輸入 <code>hexo server</code>，可縮寫 <code>hexo s</code></li>
<li>輸入 <code>hexo deploy</code>，正式將文章上傳至網路空間</li>
<li>在網址列輸入 https://你的github帳號.github.io，看是否成功</li>
</ol>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10242893">Ray - 試著學 Hexo - 部署你的第一個部落格</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo教學(四) 新增文章與常用指令</title>
    <url>/2020/10/23/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E5%9B%9B)%E6%96%B0%E5%A2%9E%E6%96%87%E7%AB%A0%E8%88%87%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>在上一篇匯入主題後，這篇我們來新增一篇文章，輸入指令後，會在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _post 中看到我們新建立的檔案。<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _post<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ *.md</p>
<ul>
<li>輸入 <code>hexo new &#39;文章標題&#39;</code></li>
<li>檔案格式為 *.md</li>
<li>寫法為 markdown</li>
</ul>
<h3 id="文章與樣板-scaffolds"><a href="#文章與樣板-scaffolds" class="headerlink" title="文章與樣板 scaffolds"></a>文章與樣板 scaffolds</h3><p>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ _drafts.md<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ _page.md<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─  _post.md<br>通常 hexo新增文章時，預設利用 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _source內的 _post.md新增一篇文章，其三份檔案的功能如下 :</p>
<ul>
<li>_drafts.md，指令為 <code>hexo new drafts &#39;文章標題&#39;</code>，用於存放草稿且不會產生靜態檔案。</li>
<li>_page.md，指令為 <code>hexo new page &#39;文章標題&#39;</code>，新開一個導覽頁面，像是關於我、歸檔以及標籤等網站分頁。</li>
<li>_post.md，指令為 <code>hexo new post &#39;文章標題&#39;</code>，用於新增文章且會產生靜態檔案。</li>
</ul>
<p>可以在這些樣板檔案中規劃需要的標籤或者分類以及其他的資訊，如以下區塊 :</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>標籤與分類，會在其他篇說明。</p>
<h2 id="常見-markdown語法"><a href="#常見-markdown語法" class="headerlink" title="常見 markdown語法"></a>常見 markdown語法</h2><p>Markdown語法有非常多，這邊例舉幾個常用語法。</p>
<h3 id="標題類"><a href="#標題類" class="headerlink" title="標題類"></a>標題類</h3><table>
<thead>
<tr>
<th>符號</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>h1標題~h6標題</td>
</tr>
<tr>
<td>######</td>
<td>h1標題~h6標題</td>
</tr>
<tr>
<td>- + 空格</td>
<td>無序清單</td>
</tr>
<tr>
<td>1. + 空格</td>
<td>有序清單</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>引用</td>
</tr>
<tr>
<td><code>``</code></td>
<td>程式碼註解</td>
</tr>
<tr>
<td><code>```</code></td>
<td>程式碼區塊(上面三個下面三個)</td>
</tr>
</tbody></table>
<h3 id="文字類"><a href="#文字類" class="headerlink" title="文字類"></a>文字類</h3><table>
<thead>
<tr>
<th>符號</th>
<th>功能</th>
<th>實際效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>**文字**</code></td>
<td>粗體</td>
<td><strong>文字</strong></td>
</tr>
<tr>
<td><code>*文字*</code></td>
<td>斜體</td>
<td><em>文字</em></td>
</tr>
<tr>
<td><code>&lt;u&gt;文字&lt;u&gt;</code></td>
<td>底線</td>
<td><u>文字<u></td>
</tr>
<tr>
<td><code>~~文字~~</code></td>
<td>刪節線</td>
<td><del>文字</del></td>
</tr>
<tr>
<td><code>&lt;font color=#FF0000&gt;紅色&lt;/font&gt;</code></td>
<td>文字顏色</td>
<td><font color=#FF0000>紅色</font></td>
</tr>
<tr>
<td><code>[連結文字](網址)</code></td>
<td>超連結文字</td>
<td><a href="%E7%B6%B2%E5%9D%80">連結文字</a></td>
</tr>
<tr>
<td><code>![圖片文字](網址)</code></td>
<td>圖片</td>
<td><img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="Google"></td>
</tr>
</tbody></table>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// :---  靠左對齊</span><br><span class="line">// ---:  靠右對齊</span><br><span class="line">// :---: 置中對齊</span><br><span class="line">|<span class="string"> 標題一 </span>|<span class="string"> 標題二 </span>|<span class="string"> 標題三 </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> -------- </span>|<span class="string">-------</span>|</span><br><span class="line">|<span class="string"> 文字 </span>|<span class="string"> 文字 </span>|<span class="string"> 文字</span></span><br></pre></td></tr></table></figure>

<h2 id="hexo常用指令"><a href="#hexo常用指令" class="headerlink" title="hexo常用指令"></a>hexo常用指令</h2><p>之後會輸入以下數次，其實多打幾次就會記住了。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>hexo generate</code></td>
<td>產生靜態檔案</td>
</tr>
<tr>
<td><code>hexo server</code></td>
<td>啟動模擬網頁伺服器</td>
</tr>
<tr>
<td><code>hexo clean</code></td>
<td>刪除編譯完成的靜態檔案</td>
</tr>
<tr>
<td><code>hexo deploy</code></td>
<td>部屬檔案至 github page</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學 404頁面</title>
    <url>/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8404/</url>
    <content><![CDATA[<h2 id="建立-404頁面"><a href="#建立-404頁面" class="headerlink" title="建立 404頁面"></a>建立 404頁面</h2><ol>
<li>輸入 <code>hexo new page 404</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source\404\index.md 增加以下資訊<ul>
<li>comments，若之後有開啟評論功能，在這邊先將它關閉</li>
<li>permalink，網站中的固定連結<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="number">404</span> <span class="bullet">-</span> <span class="string">您似乎來到不對的地方~</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-27 13:45:41</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">/404</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>增加頁面說明文字。<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 您要找的網頁不存在。</span></span><br><span class="line"></span><br><span class="line">很抱歉，您目前存取的頁面不存在。</span><br><span class="line"></span><br><span class="line">請點擊[<span class="string">這裡</span>](<span class="link">https://您的帳號.github.io/</span>)回首頁。</span><br></pre></td></tr></table></figure>
建立好上述資訊後重新建立靜態檔案，github的預設 404頁面就會使用我們新建的 404頁面了。</li>
</ol>
<p>另外，在 github中有兩種方式都能讀取到 404頁面，</p>
<ul>
<li>若 404路徑為 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span>source\404\index.md<ul>
<li>permalink就設定為 <code>permalink: /404</code></li>
</ul>
</li>
<li>若 404路徑為 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span>source\404.md <ul>
<li>permalink就設定為 <code>permalink: /404.html</code> </li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/creating-a-custom-404-page-for-your-github-pages-site">Creating a custom 404 page for your GitHub Pages site</a></li>
<li><a href="https://hexo.io/zh-tw/docs/permalinks.html">Hexo - Permalinks</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10249685">Ray - 試著學 Hexo - SEO 篇 - 新增你的 404 頁面</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學 Next主題設定與頁面功能(Ver. 8)</title>
    <url>/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8Next%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A/</url>
    <content><![CDATA[<p>由於自己選擇了 NexT主題匯入，這邊就以 NexT的設定做介紹。<br>請找到 <code>themes/next/_config.yml</code> 這隻檔案。</p>
<h2 id="全域設定"><a href="#全域設定" class="headerlink" title="全域設定"></a>全域設定</h2><h3 id="菜單導覽"><a href="#菜單導覽" class="headerlink" title="菜單導覽"></a>菜單導覽</h3><p>可以根據實際需求開啟，<code>#</code> 移除為關閉，反之則開。</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h3 id="搜尋"><a href="#搜尋" class="headerlink" title="搜尋"></a>搜尋</h3><p>請輸入以下指令，會開始安裝額外套件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>接著搜尋 local_search的設定，將它設為 true</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="字體"><a href="#字體" class="headerlink" title="字體"></a>字體</h3><p>修改 Next主題的字體，預設為 Google font的字體資源。</p>
<ul>
<li>font $\rightarrow$ 記得開啟</li>
<li>font &gt; host $\rightarrow$ 若有其他字體資源，可將網址放這</li>
<li>global $\rightarrow$ 網站文字全部修改</li>
<li>其餘部分均能修改成不同字體</li>
</ul>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># family: Lato</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">&quot;Noto Sans TC&quot;</span></span><br><span class="line">    <span class="attr">size:</span> </span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">  <span class="attr">posts:</span></span><br></pre></td></tr></table></figure>

<h3 id="閱讀全文-More"><a href="#閱讀全文-More" class="headerlink" title="閱讀全文 More"></a>閱讀全文 More</h3><div class="tabs" id="閱讀全文"><ul class="nav-tabs"><li class="tab"><a href="#閱讀全文-1">1. 手動截斷</a></li><li class="tab active"><a href="#閱讀全文-2">2. 加入 description</a></li></ul><div class="tab-content"><div class="tab-pane" id="閱讀全文-1"><p>在文章中某的地方加入 <code>&lt;!--more--&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">文字文字文字文字文字文字文字<span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="閱讀全文-2"><p>在檔案 header部分加上 description，會根據其內容呈現。</p>
<figure class="highlight yaml"><figcaption><span>source/_posts/頁面.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="撰寫相關功能"><a href="#撰寫相關功能" class="headerlink" title="撰寫相關功能"></a>撰寫相關功能</h2><h3 id="程式碼區塊"><a href="#程式碼區塊" class="headerlink" title="程式碼區塊"></a>程式碼區塊</h3><h4 id="區塊複製"><a href="#區塊複製" class="headerlink" title="區塊複製"></a>區塊複製</h4><figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="區塊主題"><a href="#區塊主題" class="headerlink" title="區塊主題"></a>區塊主題</h4><p><a href="https://theme-next.js.org/highlight/">主題預覽</a></p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># light: default</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br></pre></td></tr></table></figure>

<h4 id="區塊標題"><a href="#區塊標題" class="headerlink" title="區塊標題"></a>區塊標題</h4><p>標題前方可以加上該程式碼為何種語言，<br>例如，.yal為 yaml，.js 為 javascript</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">```yaml 標題文字</span><br><span class="line">title: </span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">``` ```</span><br></pre></td></tr></table></figure>

<h3 id="數學符號"><a href="#數學符號" class="headerlink" title="數學符號"></a>數學符號</h3><table>
<thead>
<tr>
<th>功能名稱</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>every_page</code></td>
<td>是否讓每一頁都開啟數學符號功能</td>
</tr>
<tr>
<td><code>mathjax</code></td>
<td>是否讓 mathjax寫在檔案開頭才開啟數學符號功能</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>回到撰寫頁面</p>
<figure class="highlight yaml"><figcaption><span>source/_post/頁面.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo教學</span> <span class="string">Next主題</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Next主題相關設定</span> <span class="bullet">-</span> <span class="string">開啟數學符號以及更改字體</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="內容分頁-tabs"><a href="#內容分頁-tabs" class="headerlink" title="內容分頁 tabs"></a>內容分頁 tabs</h3><p>預設就能使用，設定為 true時，切換時較為平滑</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tabs tag</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>回到頁面撰寫時，加入以下字串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 區塊標題, 預設顯示區塊索引值 %&#125;</span><br><span class="line">&lt;!-- tab 可單獨寫分頁標題 --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>用上面的範例可以這樣寫 :</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> 閱讀全文, 2 %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab 手動截斷--&gt;</span></span></span><br><span class="line"><span class="xml">在文章中某的地方加入 `<span class="comment">&lt;!--more--&gt;</span>`</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab 加入 description--&gt;</span></span></span><br><span class="line"><span class="xml">在檔案 header部分加上 description，會根據其內容呈現。</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>若 <code>&lt;!-- tab 手動截斷--&gt;</code> 不加上該分頁標題，只有單純 <code>&lt;!-- tab --&gt;</code>，<br>則會根據區塊標題的文字自動加上索引值然後在分頁標題上顯示 <code>分頁標題 1</code> <code>分頁標題 2</code>。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> First unique name %&#125;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 1**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 2**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 3**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>
<p>自動加入分頁標題 : </p>
<div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1">First unique name 1</a></li><li class="tab"><a href="#first-unique-name-2">First unique name 2</a></li><li class="tab"><a href="#first-unique-name-3">First unique name 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>這是分頁 1</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>這是分頁 2</strong></p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>這是分頁 3</strong></p></div></div></div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="關閉-Powered-by-Hexo-amp-NexT"><a href="#關閉-Powered-by-Hexo-amp-NexT" class="headerlink" title="關閉 Powered by Hexo &amp; NexT"></a>關閉 Powered by Hexo &amp; NexT</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 Powered可以自由關閉，</p>
<h3 id="版權宣告"><a href="#版權宣告" class="headerlink" title="版權宣告"></a>版權宣告</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 copyright，可以加入版權宣告的文字敘述。</p>
<h3 id="footer-icon"><a href="#footer-icon" class="headerlink" title="footer icon"></a>footer icon</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 “# Icon name in Font Awesome.” ，可以在 <a href="https://fontawesome.com/icons">fontawesome</a>找到喜歡的 icon，將 “name”的文字更換即可，當然也可以修改 “animated”與 “color”。</p>
<h2 id="後續功能"><a href="#後續功能" class="headerlink" title="後續功能"></a>後續功能</h2><ul>
<li>摺疊</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://theme-next.js.org/docs/third-party-services/math-equations">NexT說明 - math-equations</a></li>
<li><a href="https://theme-next.js.org/docs/tag-plugins/tabs.html">NexT說明 - tabs</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10248682">Ray - 試著學 Hexo - NexT 主題篇 - NexT 還有哪些設定？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10248214">Ray - 試著學 Hexo - 試著學 Hexo - NexT 主題篇 - 可以安裝的套件 </a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
        <tag>hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 箭頭函式與this(上)</title>
    <url>/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="箭頭函式-Arrow-functions"><a href="#箭頭函式-Arrow-functions" class="headerlink" title="箭頭函式 (Arrow functions)"></a>箭頭函式 (Arrow functions)</h2><p>與一般函式相比，寫法更加簡潔，也避免了某些問題。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般函式寫法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為具名函式 - 函式陳述式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為匿名函式 - 函式表達式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭頭函式</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為箭頭函式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若函式只有單一變數，參數括號可以簡化</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  str = <span class="string">&#x27;簡化參數括號&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若函式內只有單一陳述行，大括號可以簡化，但沒有參數時，括號必須存在</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;此為箭頭函式簡易寫法。&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="箭頭函式與一般函式的差異"><a href="#箭頭函式與一般函式的差異" class="headerlink" title="箭頭函式與一般函式的差異"></a>箭頭函式與一般函式的差異</h3><p>箭頭函式除了寫法簡潔之外，它跟一般函式有甚麼差異? 每當搜尋相關介紹時，總會說明它沒有這些 : </p>
<ul>
<li><code>this</code></li>
<li><code>arguments</code> </li>
<li><code>call()</code></li>
<li><code>apply()</code></li>
<li><code>bind()</code></li>
</ul>
<p>而這些到底是甚麼? 為什麼那三個內建函式又是甚麼? 為什麼它們看起來很陌生? 在下集會來介紹，在上集中會先介紹 <code>this</code>。</p>
<p>先簡易說明一下，<code>call()</code>、<code>apply()</code>、<code>bind()</code> 這三種 JS內建函式，可以影響 <code>this</code> 的運作，若使用箭頭函式的話，由於 ES6的規則，連帶的那三個函式也跟著無法使用。<br>而 <code>arguments</code>，它為一般函式的內建參數，在箭頭函式中無此內建參數可運用，但是可以改用 ES6的其餘參數來達到同樣效果。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>看到箭頭函式的介紹時，常會看到一句話，箭頭函式沒有自己的 <code>this</code>，而 <code>this</code> 從何而來，又指向誰，為什麼會用到它? </p>
<h3 id="this是甚麼"><a href="#this是甚麼" class="headerlink" title="this是甚麼 ?"></a>this是甚麼 ?</h3><ul>
<li>this 是 JavaScript的內建關鍵字之一</li>
<li>通常會用在函式或物件中，來呼叫自身的擁有的屬性或值等等…</li>
</ul>
<h3 id="this從何而來"><a href="#this從何而來" class="headerlink" title="this從何而來 ?"></a>this從何而來 ?</h3><p>先來看個範例 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>當我們將瀏覽器打開時，就已經建立好全域環境與執行環境，而程式碼就是寫在執行環境中，而 <code>this</code> 與全域環境一起被建立。</p>
<ul>
<li>全域環境</li>
<li><code>this</code></li>
<li>執行環境</li>
</ul>
<p>當我們要呼叫 a這個變數時，由上述範例可以知道，有三種呼叫變數 a的方式 :</p>
<ul>
<li>直接呼叫</li>
<li>透過全域物件呼叫</li>
<li>透過 JS內建關鍵字 <code>this</code> 呼叫</li>
</ul>
<p>變數 a是由 var宣告的，而它的執行環境在全域環境中，於是變數 a就被建立在全域環境，接著就能透過全域物件 window找到它。</p>
<h3 id="this指向誰"><a href="#this指向誰" class="headerlink" title="this指向誰 ?"></a>this指向誰 ?</h3><p>通常我們寫程式碼時，習慣在全域環境下作業，而 <code>this</code> 在呼叫自身時，<strong>必須留意在哪個環境被呼叫，而不看在哪裡被使用</strong>，像是以下這些例子 :</p>
<ul>
<li>簡易呼叫函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全域的環境下執行函式，`this`會呼叫全域下的變數</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域阿婆&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nameFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;漂亮阿姨&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">nameFn() <span class="comment">// &#x27;全域阿婆&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>物件中呼叫函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全域的環境下執行物件中的函式，`this`則指向物件本身</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn()&#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// &#x27;小杰&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>物件裡呼叫函式並執行函式中的函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域阿婆&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn()&#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    callFn2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// 相當於直接執行 callFn2() -&gt; &#x27;全域阿婆&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="為什麼會用-this"><a href="#為什麼會用-this" class="headerlink" title="為什麼會用 this ?"></a>為什麼會用 this ?</h3><p>在 <code>this</code> 一開始有提到，它可以用在函式或物件中，來呼叫自身的擁有的屬性或值，來看以下例子 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personA = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">number</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;number&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">personA.sayHello(personA.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personB = &#123;</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">personB.sayHello()</span><br></pre></td></tr></table></figure>
<p>使用 <code>this</code> 可以讓程式碼簡化不少。</p>
<h2 id="箭頭函式與-this"><a href="#箭頭函式與-this" class="headerlink" title="箭頭函式與 this"></a>箭頭函式與 this</h2><p>上述範例中，物件裡呼叫函式並執行函式中的函式，<code>this</code> 會指向全域，而我們可以使用箭頭函式來解決這樣的問題，因為 : </p>
<ul>
<li>箭頭函式沒有自己的 <code>this</code></li>
<li>當箭頭函式中使用 <code>this</code>時，它會往上一層尋找</li>
<li>也就是說，<strong>在哪邊被使用，它就會往上一層尋找，而不看環境</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;全域阿婆&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn () &#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="keyword">const</span> callFn2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    callFn2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// &#x27;小杰&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h2><ul>
<li>箭頭函式怎麼寫 ?</li>
<li>如何知道箭頭函式沒有自己的 <code>this</code> ?</li>
<li>甚麼時候會用到 <code>this</code> ?</li>
<li><code>this</code> 在不同地方會指向誰 ?<ul>
<li>在全域環境下，若創造一個箭頭函式並使用了 <code>this</code> ，它會指向誰 ?</li>
<li>在物件中新增了一個函式並使用了 <code>this</code> ，最後在全域環境下呼叫物件內的函式，它會指向誰 ?</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/schaoss-blog/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%8D%81-10-js-%E4%B8%80%E8%88%AC%E5%87%BD%E5%BC%8F%E8%88%87%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E7%9A%84%E5%B7%AE%E7%95%B0-32ce9455ff1a">Schaos - 前端三十｜10. [JS] 一般函式與箭頭函式的差異？</a></li>
<li><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/">胡立 - 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10218937">Mooji - JS 原力覺醒 Day07 - 陳述式 表達式</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/">卡斯伯 - 鐵人賽：箭頭函式 (Arrow functions)</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN - 箭頭函式</a></li>
<li>六角學院 - JS核心篇</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 箭頭函式與this(下) - call、apply、bind</title>
    <url>/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="函式的內建方法與關鍵字"><a href="#函式的內建方法與關鍵字" class="headerlink" title="函式的內建方法與關鍵字"></a>函式的內建方法與關鍵字</h2><p>在箭頭函式與 this(上)中提到，箭頭函式沒有這些方式可以用 : </p>
<ul>
<li><code>this</code></li>
<li><code>arguments</code> </li>
<li><code>call()</code></li>
<li><code>apply()</code></li>
<li><code>bind()</code></li>
</ul>
<p>這篇我們要來看這些東西原本是怎麼運作的。</p>
<h3 id="關鍵字-this"><a href="#關鍵字-this" class="headerlink" title="關鍵字 this"></a>關鍵字 this</h3><p>複習一下 <code>this</code> 的運作 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  whoAmI: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.whoAmI()</span><br><span class="line"><span class="comment">// 由於是在物件呼叫此函式的，所以往上一層尋找時(非箭頭函式)，會找到此物件的屬性值</span></span><br></pre></td></tr></table></figure>

<h3 id="關鍵字-arguments"><a href="#關鍵字-arguments" class="headerlink" title="關鍵字 arguments"></a>關鍵字 arguments</h3><ul>
<li>一般函式內建的關鍵字之一</li>
<li>可以將傳入的參數值抓取出來形成一個類陣列<strong>物件</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="內建函式-call、apply、bind的共通點"><a href="#內建函式-call、apply、bind的共通點" class="headerlink" title="內建函式 call、apply、bind的共通點"></a>內建函式 call、apply、bind的共通點</h3><ul>
<li>JS的內建函式</li>
<li>它們都與 <code>this</code> 有所關聯</li>
<li>不需要在函式中自訂參數就能將變數塞進 <code>this</code></li>
<li>若有多個值，函式的第一個參數位置為 <code>this</code></li>
<li>也就是說<code>(this, 參數1, 參數2, 以此類推)</code></li>
</ul>
<p>接下來，我們來看，<code>call()</code>、<code>apply()</code>以及 <code>bind()</code> 如何與 <code>this</code> 運作。</p>
<h3 id="內建函式-call"><a href="#內建函式-call" class="headerlink" title="內建函式 call"></a>內建函式 call</h3><ul>
<li>單純將參數值傳入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`this為<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第二個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a)</span><br><span class="line">&#125;</span><br><span class="line">sum.call(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// &quot;this為2&quot;</span></span><br><span class="line"><span class="comment">// &quot;第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h3 id="內建函式-apply"><a href="#內建函式-apply" class="headerlink" title="內建函式 apply"></a>內建函式 apply</h3><ul>
<li>傳入的型態必須是陣列</li>
<li>功能上與 <code>call</code> 無異</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`陣列中第一個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`this為<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`陣列中第二個是<span class="subst">$&#123;b&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">sum.apply(<span class="number">1</span>, array)</span><br><span class="line"><span class="comment">// &quot;陣列中第一個是2&quot;</span></span><br><span class="line"><span class="comment">// &quot;this為1&quot;</span></span><br><span class="line"><span class="comment">// &quot;陣列中第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h3 id="內建函式-bind"><a href="#內建函式-bind" class="headerlink" title="內建函式 bind"></a>內建函式 bind</h3><ul>
<li><strong><code>bind()</code> 將建立一個新的函式</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="comment">// bind會建立一個新的函式</span></span><br><span class="line"><span class="comment">// this會對應傳入的參數 newPerson</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jay&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newDisplay = display.bind(newPerson)</span><br><span class="line">display() <span class="comment">// Jay</span></span><br><span class="line">newDisplay() <span class="comment">// Vic</span></span><br><span class="line"><span class="comment">// 新的函式會執行 console.log(newPerson.name)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="comment">// 若有多個值，bind的參數第一順位為 &#x27;this&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第一個是<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第二個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> plusTwo = sum.bind(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plusTwo()</span><br><span class="line"><span class="comment">// &quot;第一個是2&quot;</span></span><br><span class="line"><span class="comment">// &quot;第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="箭頭函式與-this"><a href="#箭頭函式與-this" class="headerlink" title="箭頭函式與 this"></a>箭頭函式與 this</h2><p>我們了解到箭頭函式沒有自己的 <code>this</code>，相對的也就沒有上述的那三種內建函式可供使用，也無法使用 <code>arguments</code>，但可以改用其餘參數來達成目的。箭頭函式與一般函式的運用，還是得看實際情況來做使用。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/@realdennis/javascript-%E8%81%8A%E8%81%8Acall-apply-bind%E7%9A%84%E5%B7%AE%E7%95%B0%E8%88%87%E7%9B%B8%E4%BC%BC%E4%B9%8B%E8%99%95-2f82a4b4dd66">realdennis - [JavaScript] 函數原型最實用的 3 個方法 — call、apply、bind</a></li>
<li><a href="https://medium.com/schaoss-blog/%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%A9%A6%E6%9C%80%E6%84%9B%E5%95%8F%E7%9A%84-apply-bind-call-708f57518776">Schaos - 一次搞懂前端面試最愛問的 apply、bind、call</a> </li>
<li><a href="https://ithelp.ithome.com.tw/articles/10195896">Henry Chang - JavaScript - call，apply，bind</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 解構賦值與其餘參數</title>
    <url>/2020/11/04/javascript/ES6%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E8%88%87%E5%85%B6%E9%A4%98%E5%8F%83%E6%95%B8/</url>
    <content><![CDATA[<h2 id="解構賦值"><a href="#解構賦值" class="headerlink" title="解構賦值"></a>解構賦值</h2><blockquote>
<p>解構賦值 (Destructuring assignment) 語法是一種 JavaScript 運算式，可以把陣列或物件中的資料解開擷取成為獨立變數。</p>
</blockquote>
<p>通常我們拿到的資料會是物件與陣列所組成，為了處理這些資料，需要使用迴圈、判斷等語法來取得相對應的資料，而陣列所包含的資料可能是複合性的或者物件屬性名稱不是我們要的，這時可以利用解構、展開運算子以及其餘參數混合使用達成我們的處理目的。若要透過函式處理更多事情，也能在函式的參數中使用。</p>
<p>在以下的段落會介紹 : </p>
<ul>
<li>陣列解構</li>
<li>物件解構</li>
<li>解構預設值</li>
<li>其餘參數與展開運算子</li>
</ul>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><h3 id="變數賦值"><a href="#變數賦值" class="headerlink" title="變數賦值"></a>變數賦值</h3><ul>
<li>宣告多個變數後，將它們用陣列的中括號包起來 <code>let [變數1, 變數2]</code></li>
<li>變數會<strong>對應</strong>陣列中絕對位置的陣列值，順序為由左至右</li>
<li>若缺少對應值，該變數則為 undefined</li>
</ul>
<h3 id="均有對應變數"><a href="#均有對應變數" class="headerlink" title="均有對應變數"></a>均有對應變數</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有變數在對應的位置賦值</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c ,d, e) </span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<h3 id="缺少變數"><a href="#缺少變數" class="headerlink" title="缺少變數"></a>缺少變數</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有限的變數在對應的位置賦值</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [x, , , y, z] = array</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) </span><br><span class="line"><span class="comment">// 2 8 10</span></span><br></pre></td></tr></table></figure>
<h3 id="缺少對應值"><a href="#缺少對應值" class="headerlink" title="缺少對應值"></a>缺少對應值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數皆已宣告，但對應位置沒有賦予值</span></span><br><span class="line"><span class="comment">// 如同直接執行 console.log(d)</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, , , <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c ,d, e)</span><br><span class="line"><span class="comment">// 2 4 undefined undefined 10</span></span><br></pre></td></tr></table></figure>
<h3 id="其餘參數賦予新陣列"><a href="#其餘參數賦予新陣列" class="headerlink" title="其餘參數賦予新陣列"></a>其餘參數賦予新陣列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以利用其餘參數將剩下的元素形成一組新陣列</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// 2 4 [6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h3><ul>
<li>利用解構將變數賦值後，再將它們的值做交換</li>
<li>利用解構方式將變數值做交換時，上一行必須要有<strong>分號</strong>，否則會出錯</li>
<li>若使用套件 ESLint檢查的話，需要換個方式寫，將外層以大括號區隔<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [seatA, seatB] = [<span class="string">&#x27;Jay&#x27;</span>, <span class="string">&#x27;Vic&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(seatA, seatB); <span class="comment">// &quot;Jay&quot; &quot;Vic&quot;</span></span><br><span class="line"></span><br><span class="line">[seatA, seatB] = [seatB, seatA]</span><br><span class="line"><span class="comment">// 不用分號的寫法</span></span><br><span class="line"><span class="comment">// &#123;[seatA, seatB] = [seatB, seatA]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(seatA, seatB) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; &quot;Jay&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="字串解構"><a href="#字串解構" class="headerlink" title="字串解構"></a>字串解構</h3><ul>
<li>可以將字串每一個字元作為變數值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Vic&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [a, b ,c] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// &quot;V&quot; &quot;i&quot; &quot;c&quot; </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><ul>
<li>宣告多個變數後，將它們用物件的大括號包起來 <code>let &#123;變數1, 變數2&#125;</code></li>
<li>但它<strong>沒有順序</strong></li>
</ul>
<h3 id="一般物件解構"><a href="#一般物件解構" class="headerlink" title="一般物件解構"></a>一般物件解構</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 宣告 name與 age為變數，只不過與物件內的屬性名稱相同</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name, age) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; 18</span></span><br></pre></td></tr></table></figure>

<h3 id="無宣告物件解構"><a href="#無宣告物件解構" class="headerlink" title="無宣告物件解構"></a>無宣告物件解構</h3><ul>
<li>未宣告的物件屬性值可以解構給已宣告變數<ul>
<li>如同上一個範例，變數的值為物件的屬性值</li>
<li>這裡不需將物件宣告</li>
</ul>
</li>
<li><strong>但變數名稱需與未宣告的物件屬性名稱相同</strong></li>
<li>已宣告的變數名稱可以再次給予新名稱</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:anonymous, <span class="attr">age</span>:anonymousAge&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;ccc&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125; </span><br><span class="line"><span class="built_in">console</span>.log(anonymous, anonymousAge) </span><br><span class="line"><span class="comment">// &quot;ccc&quot; 18</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解構預設值"><a href="#解構預設值" class="headerlink" title="解構預設值"></a>解構預設值</h2><ul>
<li>在解構陣列與物件時，若沒有對應的變數值，預設會是 undefined</li>
<li>可以在宣告時先給予一個預設值</li>
</ul>
<h3 id="陣列解構預設值"><a href="#陣列解構預設值" class="headerlink" title="陣列解構預設值"></a>陣列解構預設值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name=<span class="string">&#x27;匿名登入&#x27;</span>, age=<span class="string">&#x27;隱藏年齡&#x27;</span>] = [<span class="string">&#x27;Vic&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(name, age) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; &quot;隱藏年齡&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="物件解構預設值"><a href="#物件解構預設值" class="headerlink" title="物件解構預設值"></a>物件解構預設值</h3><ul>
<li>給予預設值的同時，也可以賦予新的變數名稱，但只有物件可以</li>
<li><code>let &#123; 已宣告變數名:新的變數名 = 預設值 &#125;</code></li>
<li><code>let &#123;name:anonymous = &#39;匿名登入&#39;&#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:anonymous=<span class="string">&#x27;匿名登入&#x27;</span>, age=<span class="string">&#x27;隱藏年齡&#x27;</span>&#125; = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(anonymous, age)</span><br><span class="line"><span class="comment">// &quot;匿名登入&quot; &quot;隱藏年齡&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函式與預設值"><a href="#函式與預設值" class="headerlink" title="函式與預設值"></a>函式與預設值</h3><ul>
<li>可以將物件解構作為函式的參數並設定預設值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 單純參數預設值 */</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">name=<span class="string">&#x27;匿名登入&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">fnA() <span class="comment">// &quot;匿名登入&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物件解構預設值 */</span></span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">(<span class="params">&#123;name=<span class="string">&#x27;匿名登入&#x27;</span>, height=<span class="number">150</span>&#125;=&#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, height)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name:<span class="string">&#x27;Vic&#x27;</span>, </span><br><span class="line">  height:<span class="number">180</span></span><br><span class="line">&#125;</span><br><span class="line">fnB() <span class="comment">// &quot;匿名登入&quot; 150</span></span><br><span class="line">fnB(person) <span class="comment">// &quot;Vic&quot; 180</span></span><br></pre></td></tr></table></figure>

<h2 id="其餘參數與展開運算子"><a href="#其餘參數與展開運算子" class="headerlink" title="其餘參數與展開運算子"></a>其餘參數與展開運算子</h2><ul>
<li>寫法為三個點 <code>...</code></li>
<li>必須寫在變數名稱前面 <code>...變數名稱</code></li>
<li>兩者常會混淆，它們寫法相同，但行為不同</li>
</ul>
<h3 id="其餘參數"><a href="#其餘參數" class="headerlink" title="其餘參數"></a>其餘參數</h3><blockquote>
<p>其餘參數（rest parameter） 語法可以讓我們表示不確定數量的參數，並將其視為一個陣列。</p>
</blockquote>
<ul>
<li>可以將剩餘資料收集並組成一個新陣列</li>
<li>它為實體陣列，也就是說，它可以使用 <code>forEach()</code>、<code>length</code>等等…</li>
<li>它必需在最後一個位置才能使用</li>
</ul>
<h4 id="收集剩餘資料"><a href="#收集剩餘資料" class="headerlink" title="收集剩餘資料"></a>收集剩餘資料</h4><p>再看一次陣列解構中，有提到其餘參數的運用 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 陣列解構後賦予變數值</span></span><br><span class="line"><span class="comment">// 利用其餘參數將變數 c賦予一組新陣列</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// 2 4 [6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="展開運算子"><a href="#展開運算子" class="headerlink" title="展開運算子"></a>展開運算子</h3><blockquote>
<p>展開運算子(…) 允許可迭代的陣列或字串展開成０到多個參數(如果是function的話)或是０到多個元素(如果是array或字組的話)，或如果是物件的話則展開成０到多個key-value pair。</p>
</blockquote>
<ul>
<li>若對陣列展開，它會 return陣列中每一個值</li>
<li>若對物件展開，它會 return物件中每一個屬性名稱</li>
<li>若對字串展開，它為類陣列，會 return類陣列中每一個值</li>
</ul>
<h4 id="將陣列展開"><a href="#將陣列展開" class="headerlink" title="將陣列展開"></a>將陣列展開</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...array) </span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>

<h4 id="將字串展開"><a href="#將字串展開" class="headerlink" title="將字串展開"></a>將字串展開</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name =<span class="string">&#x27;Vic&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(...name)</span><br><span class="line"><span class="comment">// &quot;V&quot; &quot;i&quot; &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="綜合使用"><a href="#綜合使用" class="headerlink" title="綜合使用"></a>綜合使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b, ...c</span>) =&gt;</span> &#123; <span class="comment">// 將剩餘陣列值收集</span></span><br><span class="line">  <span class="built_in">console</span>.log(a+b)</span><br><span class="line">  <span class="comment">// reduce() 可以將陣列內所有值累加</span></span><br><span class="line">  <span class="built_in">console</span>.log(c.reduce(<span class="function">(<span class="params">d,e</span>) =&gt;</span> d+e))</span><br><span class="line">&#125;</span><br><span class="line">fn(...array) <span class="comment">// 將陣列展開</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<h2 id="解構賦值與其餘參數"><a href="#解構賦值與其餘參數" class="headerlink" title="解構賦值與其餘參數"></a>解構賦值與其餘參數</h2><p>參考別人的 JS寫法時，常會看到利用解構賦值與其餘參數的混和運用，但自己寫的時候卻常混淆它們的行為，三種不同的行為模式卻可以達成類似的目的，於是寫了這篇給自己看。要是能善加利用解構賦值、展開運算子以及其餘參數，對於函式的參數設計上會有很大的幫助。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN - 解構賦值</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters">MDN - 其餘參數</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN - 展開運算子</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/25/javascript-destructuring/">卡斯伯 - 鐵人賽：ES6 解構賦值</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/destructuring.html">從ES6開始的JavaScript學習生活 - 解構賦值</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/rest_spread.html">從ES6開始的JavaScript學習生活 - 展開運算符與其餘運算符</a></li>
<li><a href="https://medium.com/@realdennis/%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC-%E8%A8%AD%E8%A8%88%E5%87%BD%E6%95%B8%E6%99%82%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-javascript-1466f37d24f0">realdennis - 解構賦值 — 設計函數時的小技巧 JavaScript</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6變數宣告與全域環境</title>
    <url>/2020/10/29/javascript/ES6%E8%AE%8A%E6%95%B8%E5%AE%A3%E5%91%8A%E8%88%87%E5%85%A8%E5%9F%9F%E7%92%B0%E5%A2%83/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>一種被廣泛使用的程式語言，好上手也最容易踩雷，從 ES5進化到 ES6後增加了一些變數宣告方式與不少的語法糖，其歷史沿革已有很多前輩說明，為了方便之後描述，以下 JavaScript簡稱為 JS。</p>
<h2 id="JS-變數宣告"><a href="#JS-變數宣告" class="headerlink" title="JS 變數宣告"></a>JS 變數宣告</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>在 ES5時期，要宣告一個變數會使用 var作為開頭，但它有個缺點，就是它會建立在全域，在後續開發上會讓造成混淆，像是以下例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// window是 JS的最上層，也就是全域</span></span><br><span class="line"><span class="comment">// 它有很多 JS內建的事件與函式</span></span><br></pre></td></tr></table></figure>
<p>透過瀏覽器(開發者模式)來看，會發現在 window中找得到 a這個變數，這很可能讓後續寫下的變數或者函式抓到同樣的變數(註1)，進而造成不必要的錯誤。不過，它不是不能用，根據實際情況改變寫法才是我們要的。<br>順帶一提，若有安裝 ESLint這類的檢查工具，這個宣告方式還是會被建議改成 let。</p>
<p>註1 : 若函式裏頭未宣告且命名一個變數並賦予值，那麼此變數就會在全域環境中建立一個該變數的名稱(這個行為是 <strong>Hoisting</strong>，中文名為提升)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// c is not defined</span></span><br><span class="line"><span class="comment">// 執行 b函式時，全域環境中建立了名為 a的變數</span></span><br><span class="line"><span class="comment">// 而變數 c是在函式內宣告，因此在&quot;全域環境&quot;中找不到變數 c</span></span><br></pre></td></tr></table></figure>

<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ES6中，新增了 let與 const，這邊先介紹 let。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>只在某區塊(例如函式)中有作用</li>
<li>無法重複宣告同樣變數名稱</li>
<li>變數的值可改變</li>
</ul>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><p>為了解決 var所帶來的困擾，使用 let來做為變數宣告會是一個比較好的方式，它的作用範圍被限制在某個區塊中，就算不在函式中宣告，在 window中也找不到利用 let所宣告的變數。以下為範例 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>無法重複宣告</li>
<li>變數的值不可改變</li>
<li>若賦予的值為陣列或物件，可以改變其內部屬性</li>
</ul>
<p>使用 const宣告的變數為<strong>常數</strong>，無法改變其值，類似唯讀。</p>
<h2 id="全域環境"><a href="#全域環境" class="headerlink" title="全域環境"></a>全域環境</h2><p>上述的範例中會看到 window.a，這其實是物件的寫法，利用 var來宣告變數時，會在 window中新增一個物件屬性，為什麼會提到物件? 因為在說明 let時，自己不禁有個疑問，<code>let a</code> 有宣告，但在全域中卻找不到，那它去哪裡了?</p>
<h3 id="全域之複合環境"><a href="#全域之複合環境" class="headerlink" title="全域之複合環境"></a>全域之複合環境</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">這裡</a>似乎有相關的說明。目前自己的理解是，全域環境中是一個複合環境，包含 : </p>
<ul>
<li>物件環境 Object Environment</li>
<li>聲明環境 Declarative Environment<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以表格來看的話，類似像這樣 : <table>
<thead>
<tr>
<th>聲明環境</th>
<th>物件環境</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>10</td>
</tr>
<tr>
<td>b</td>
<td>funciton()</td>
</tr>
</tbody></table>
</li>
</ul>
<p>而 JS是物件導向，以物件來看的話，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 會在 Global內發現它們</span></span><br><span class="line">&#123;</span><br><span class="line">  a: <span class="number">10</span></span><br><span class="line">  b: f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="瀏覽器中的-Scope"><a href="#瀏覽器中的-Scope" class="headerlink" title="瀏覽器中的 Scope"></a>瀏覽器中的 Scope</h3><p>對於瀏覽器來說，當執行環境執行程式碼時，會在瀏覽器的 Scope產生 Global與 Script，而範例的執行環境就是全域環境，所以當變數沒有被告知用哪一種變數宣告，那麼就會根據 JS規則將此變數建立在 Global，若在全域環境下也用 var宣告，那麼就會是建立在 Global。<br>而使用 let與 const宣告時，它們會被建立在 Script，這就是為什麼無法在 window中找到的原因，因為它們的建立規則不是建立在 Global。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/pvt5r486/javascript-weird-day-2-%E5%85%A8%E5%9F%9F%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%85%A8%E5%9F%9F%E7%89%A9%E4%BB%B6-428bc0d61085">pvt5r486 - [JavaScript Weird] Day 2 — 全域執行環境與全域物件</a></li>
<li><a href="https://hsiangfeng.github.io/javascript/20200425/539985371/">Ray - 淺談 var 與 let 的差異以及有無宣告變數的差異</a></li>
<li><a href="https://medium.com/@realdennis/%E4%B8%80%E6%AC%A1%E8%AA%AA%E6%B8%85%E6%A5%9A-javascript-%E4%B8%AD%E5%AE%A3%E5%91%8A%E7%9A%84%E5%90%84%E7%A8%AE%E6%8F%90%E5%8D%87%E8%A1%8C%E7%82%BA-var-function-let-const-dd9175d063f0">realdennis - 一次說清楚 JavaScript 中宣告的各種提升行為（var、function、let/const）</a></li>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">Fun Lee - 关于 const 和 let 声明的变量不在 window 上</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>迴圈之變數作用域</title>
    <url>/2020/11/13/javascript/%E8%BF%B4%E5%9C%88%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>很多技術筆記說明 JS變數的作用域時，都會使用迴圈與一個 JS內建函式來說明作用域的不同之處，但為什麼使用了 <code>setTimeout()</code> 這個語法，可以讓結果不同?<br>主要是因為以下的運作方式與觀念，會讓結果不同 : </p>
<ul>
<li>變數宣告影響作用域</li>
<li>執行緒</li>
<li>Callback Function </li>
</ul>
<h2 id="迴圈與變數作用域"><a href="#迴圈與變數作用域" class="headerlink" title="迴圈與變數作用域"></a>迴圈與變數作用域</h2><p>在以下的例子中，是最常見的 for迴圈，使用不同的變數宣告方式並印出結果，而迴圈宣告的變數會建立在不同地方，假設宣告變數在在全域環境中，那麼</p>
<ul>
<li>使用 var宣告的變數，被建立在全域環境底下。</li>
<li>使用 let宣告的變數，被建立在獨立的區塊中，也就是該函式的執行環境。</li>
</ul>
<h3 id="直接印出迴圈結果"><a href="#直接印出迴圈結果" class="headerlink" title="直接印出迴圈結果"></a>直接印出迴圈結果</h3><ul>
<li>執行結果看不出差異</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span> ; y &lt; <span class="number">5</span> ; y++) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 結果都是</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="一秒後印出所有結果"><a href="#一秒後印出所有結果" class="headerlink" title="一秒後印出所有結果"></a>一秒後印出所有結果</h3><ul>
<li>使用 JS內建函式 <code>setTimeout()</code>，卻讓執行結果改變。</li>
</ul>
<ol>
<li>使用 var宣告變數<ul>
<li>var的最小作用域為 function</li>
<li>在全域環境下，for迴圈每跑一次，事件佇列就會多一個 <code>setTimeout()</code>，當 for迴圈跑完換事件佇列內的 <code>setTimeout()</code> 執行時，i 已經改變成 5 了，所以會有五個 5。</li>
<li><strong>但是，為什麼結果是 5 不是 4 ?</strong></li>
<li>i 已經在全域環境下建立了，也因此執行第一次迴圈時，i++的關係，i 就變成了 1，總共要執行五次，所以 i 為 5。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 let宣告變數<ul>
<li>let的最小作用域為 <code>&#123; &#125;</code> ，例如 <code>for()&#123;&#125;</code>、<code>if()&#123;&#125;</code></li>
<li>每當進入事件佇列時，當下的 y 值會跟著進去</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span> ; y&lt;<span class="number">5</span> ; y++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上述的例子，有說到 <code>setTimeout()</code> 會進入<strong>事件佇列</strong>，接著因變數宣告方式不同會改變結果，這跟接下來的說明有關。</p>
<h2 id="Callback-Function-與執行緒"><a href="#Callback-Function-與執行緒" class="headerlink" title="Callback Function 與執行緒"></a>Callback Function 與執行緒</h2><p>函式的參數不僅可以放單一值、陣列以及物件，也可以放函式，而 JS的執行方式會影響函式的運作時機。</p>
<h3 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h3><ul>
<li>某個函式做為另一個函式的參數值。</li>
<li>例如 <code>setTimeout()</code> <ul>
<li><code>setTimeout( 某函式, 等待多久後印出的時間 )</code></li>
<li><code>setTimeout( function(), 1000 )</code></li>
<li>若依賴其他函式過深，也就是重複這種型態，就會變成所謂的波動拳。</li>
<li>衍伸出 <strong>Promise</strong> 的概念。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout()，1秒後印出該函式的結果</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Callback Function&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// &quot;Callback Function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="執行緒"><a href="#執行緒" class="headerlink" title="執行緒"></a>執行緒</h3><ul>
<li>JS執行方式為單線程</li>
<li>執行過程<ul>
<li>由上到下執行。</li>
<li>執行函式時，會先放進執行堆疊，直到 return結果後離開(以下範例用 <code>console.log()</code> 代替)。</li>
<li>執行<strong>事件</strong>時，會等待被觸發，例如點擊，計時器之類的事件，它們會暫時在瀏覽器中等待。</li>
<li>當事件被觸發時， JS會將它要執行的函式放進事件佇列，等執行堆疊的函式處理完畢後，再處理佇列內的函式。</li>
<li>為什麼會有事件?<ul>
<li><code>setTimeout()</code>，可以寫成 <code>window.setTimeout()</code>，也就是說，事件是瀏覽器的 API給 JS使用的。</li>
</ul>
</li>
<li>程式碼的事件 &gt; 等待觸發 &gt; 觸發 &gt; 事件佇列</li>
</ul>
</li>
</ul>
<h4 id="測試範例"><a href="#測試範例" class="headerlink" title="測試範例"></a>測試範例</h4><ul>
<li>測試一</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由上到下執行，函式執行後進入執行堆疊，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line">fnB()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試二</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在另一個函式內執行函式，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">  fnB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試三</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在另一個函式內執行函式，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 B&quot;，接著產生 &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fnB()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>

<ul>
<li>測試四</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函式內執行事件 setTimeout() </span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著 3秒後產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(fnB, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試五<ul>
<li>JS的執行方式若遇到事件時，會等待事件觸發。</li>
<li>直到執行堆疊處理完畢後，看事件是否觸發，若觸發則放入事件佇列中並執行事件內的函式。</li>
<li>也就是說，無論 <code>setTimeout()</code> 秒數設為 0秒還是3秒，都會先等待觸發並往下處理執行堆疊內的函式。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 B&quot;，接著 3秒後產生 &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fnB, <span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 與預期結果不同 !!!</span></span><br><span class="line"><span class="comment">// &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="comment">// &quot;我是函式 B&quot; &lt;- 3秒後產生</span></span><br></pre></td></tr></table></figure>

<h2 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h2><p>以下面兩個例子來說，它包含了 : </p>
<ul>
<li>var的作用域<ul>
<li>用 function區隔會有不同結果，可以做到與 let相同的事。</li>
</ul>
</li>
<li>執行緒<ul>
<li>函式的執行堆疊與事件觸發之事件佇列(等待)。</li>
</ul>
</li>
<li>Callback Function<ul>
<li>在 <code>setTimeout()</code> 中執行另一個函式。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數 z已被 function區隔，因此全域環境中是找不到 z這個變數的，</span></span><br><span class="line"><span class="comment">// 但它還是會存在於函式 fnA內，</span></span><br><span class="line"><span class="comment">// 秒數的 z值屬於 setTimeout 這個函式，也因此被區隔，</span></span><br><span class="line"><span class="comment">// 進入事件佇列後，console.log(z) 執行的是函式 fnA的 z值，也就是 5。</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span> ; z &lt; y ; z++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(z)          </span><br><span class="line">   &#125;, <span class="number">1000</span>*z)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A，接著執行函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數 z的值，隨著函式 fnB進入了執行堆疊，</span></span><br><span class="line"><span class="comment">// 執行堆疊內，函式執行了事件，等待事件觸發後，z值一起進入了事件佇列中，</span></span><br><span class="line"><span class="comment">// z值待在 fnB的區塊中，此時 console.log(x) 執行的是函式 fnB所帶來的值。</span></span><br><span class="line"><span class="comment">// 閉包的概念</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span> ; z &lt; y ; z++) &#123;</span><br><span class="line">    fnB(z)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A，接著執行函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x)          </span><br><span class="line">  &#125;, <span class="number">1000</span>*x)</span><br><span class="line">&#125; </span><br><span class="line">fnA(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="延伸概念"><a href="#延伸概念" class="headerlink" title="延伸概念"></a>延伸概念</h3><ul>
<li>閉包</li>
<li>Promise</li>
<li>同步與非同步</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10192739">Kuro Hsu - 重新認識 JavaScript: Day 18 Callback Function 與 IIFE</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10193009">Kuro Hsu - 重新認識 JavaScript: Day 19 閉包 Closure</a></li>
<li><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">PJCHENder那些沒告訴你的小細節 - [筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法入門(一) 演算法與大 O 符號</title>
    <url>/2020/10/19/%E6%BC%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%96%80/%E6%BC%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%96%80(%E4%B8%80)%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E5%A4%A7%20O%20%E7%AC%A6%E8%99%9F/</url>
    <content><![CDATA[<h2 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h2><blockquote>
<p>演算法三步驟，它是明確的、有限的且有效率的</p>
</blockquote>
<ol>
<li>輸入</li>
<li>計算步驟</li>
<li>輸出</li>
</ol>
<h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>假設現在目標是砍倒一棵樹，且不限時間，使用斧頭會需要很多時間也浪費力氣，使用電鋸省力也省時，換成步驟來看的話，斧頭需要很多砍很多下才會倒，且需要的時間非常多，換成電鋸後，省時省力。</p>
<p>再假設你買了一部90萬的車輛，朋友問你這部車買了多少? 你只能打字回答，這時你會怎麼回覆呢? 9000百元? 900千元?  或者90萬元? 顯然是90萬元最符合答案也能最快回答。</p>
<h2 id="如何描述程式中時間與空間的關係呢"><a href="#如何描述程式中時間與空間的關係呢" class="headerlink" title="如何描述程式中時間與空間的關係呢?"></a>如何描述程式中時間與空間的關係呢?</h2><p>我們會以數學符號之<strong>漸進符號</strong> $O$，其表示為函數增長關係。</p>
<ul>
<li>漸進符號 $O$<ul>
<li>bigO，通常會寫成 $O()$</li>
</ul>
</li>
<li>時間複雜度<ul>
<li>隨著輸入值成長之執行步驟</li>
</ul>
</li>
<li>空間複雜度<ul>
<li>隨著輸入值成長之記憶體暫用空間</li>
</ul>
</li>
</ul>
<p>而通常我們為了簡化表達方式，會取其極限值，以下為一些例子 :</p>
<ul>
<li>常數 $\rightarrow$ 1</li>
<li>$n、2n、3n \rightarrow n$</li>
<li>$n^2+2n \rightarrow n^2$</li>
<li>以此類推</li>
</ul>
<h2 id="執行複雜度表示方式"><a href="#執行複雜度表示方式" class="headerlink" title="執行複雜度表示方式"></a>執行複雜度表示方式</h2><p>來看以下的例子，小杰被師父指派去賣漢堡，每個漢堡50元 :</p>
<ul>
<li><p>範例一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sell = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> total = n*<span class="number">50</span></span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函式一共執行 2個步驟，也就是說輸入無窮大時，也只會執行 2個步驟，那麼它的時間複雜度則為 $O(1)$，空間複雜度為 $O(1)$，因為只使用了 total這個變數。</p>
</li>
<li><p>範例二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sell = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> total = n*<span class="number">50</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`小杰累計賣出<span class="subst">$&#123;i&#125;</span>個漢堡~`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line">sell(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>for迴圈執行了 n次再加上前後兩個步驟共 n+2次，以時間複雜度來表示則為 $O(n)$，空間複雜度為 $O(1)$，使用了 total與 i兩個變數</p>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://www.notion.so/JavaScript-49b80c4a10b9498ca0afa954ee8982f3#38cbcc1d017545b8bc094561c3593806">Long - 用JavaScript學習資料結構與演算法</a></li>
<li><a href="https://www.notion.so/JavaScript-49b80c4a10b9498ca0afa954ee8982f3#3ab72425fc6746a4985796fe3b18f2db">胡程維 - 初學者學演算法</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>演算法入門</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>演算法入門</tag>
      </tags>
  </entry>
</search>
