<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Google試算表作為線上資料庫 - 讀取資料</title>
    <url>/2020/11/18/Google%E8%A9%A6%E7%AE%97%E8%A1%A8%E4%BD%9C%E7%82%BA%E7%B7%9A%E4%B8%8A%E8%B3%87%E6%96%99%E5%BA%AB-%E8%AE%80%E5%8F%96%E8%B3%87%E6%96%99/</url>
    <content><![CDATA[<p>想要弄自己的資料庫，卻又不知道該怎麼做，只知道要建立欄位，而Google的試算表就能達成這件事。只要 : </p>
<ul>
<li>建立欄位名稱</li>
<li>輸入欄位資料</li>
<li>發布至網路</li>
<li>簡易的程式碼</li>
</ul>
<p>就能撈取 JSON格式資料並使用 Get、Post等方式來存取了。</p>
<h2 id="建立資料"><a href="#建立資料" class="headerlink" title="建立資料"></a>建立資料</h2><ul>
<li>在試算表中建立一份新檔案</li>
<li>在第一行中輸入欄位名稱(資料庫關係，建議全英文)</li>
<li>在第二行中輸入對應資料，像是這樣</li>
</ul>
<table>
<thead>
<tr>
<th>skill</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>網頁標籤與結構化</td>
</tr>
<tr>
<td>CSS/SASS</td>
<td>使用 SASS格式撰寫 CSS</td>
</tr>
</tbody></table>
<h2 id="發布資料"><a href="#發布資料" class="headerlink" title="發布資料"></a>發布資料</h2><p>發布資料有兩種方式 : </p>
<ol>
<li>直接將試算表發佈到網路<ul>
<li>提供給所有人檢視</li>
</ul>
</li>
<li>使用指令碼編輯器撰寫程式碼並發布<ul>
<li>知道連結的人可供檢視</li>
<li>可以不公開至網路(像是非公開資料但需要寫入)</li>
</ul>
</li>
</ol>
<p>這兩種方式中，我們會還會用到</p>
<ul>
<li>試算表的 ID，可以在試算表的網址列中找到<ul>
<li><code>https://docs.google.com/spreadsheets/d/試算表的ID/edit#gid=0</code></li>
</ul>
</li>
<li>試算表的工作表之索引值<ul>
<li>若為一般發布，索引值從 1 開始，也就是第幾張工作表</li>
<li>若使用指令碼編輯器，程式碼中的索引值為陣列，從 0 開始</li>
</ul>
</li>
</ul>
<h3 id="發布自建試算表"><a href="#發布自建試算表" class="headerlink" title="發布自建試算表"></a>發布自建試算表</h3><ul>
<li>在試算表的工具列中，找到 <code>檔案</code>，這個選項，然後選擇 <code>發佈到網路</code></li>
<li>按下發布後，對話視窗關掉即可</li>
</ul>
<h3 id="指令碼編輯器"><a href="#指令碼編輯器" class="headerlink" title="指令碼編輯器"></a>指令碼編輯器</h3><ul>
<li>在試算表的工具列中，找到 <code>工具</code> 這個選項，然後選擇 <code>指令碼編輯器</code></li>
<li>將預設的 function內容改為以下程式碼</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存取試算表資料</span></span><br><span class="line"><span class="comment">// function名稱必須是 doGet，才能使用 get方式取得資料</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="string">&#x27;試算表網址列的 ID&#x27;</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 看起來很複雜? 其實是一連串拆開後的結果</span></span><br><span class="line">  <span class="keyword">var</span> spreadsheet = SpreadsheetApp.openById(id);</span><br><span class="line">  <span class="keyword">var</span> sheet = spreadsheet.getSheets()[<span class="number">0</span>]; </span><br><span class="line">  <span class="keyword">var</span> data = sheet.getDataRange().getValues();</span><br><span class="line">  <span class="comment">// SpreadsheetApp.openById(id).getSheets()[0].getDataRange().getValues()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 將物件轉為 JSON字串，因為瀏覽器只能使用字串傳輸</span></span><br><span class="line">  <span class="keyword">var</span> dataExportFormat = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ContentService.createTextOutput(&#x27;字串&#x27;) 輸入發布的網址後，伺服器會回傳字串</span></span><br><span class="line">  <span class="comment">// 回傳的東西可以是字串、html以及 JSON</span></span><br><span class="line">  <span class="comment">// setMimeType(ContentService.MimeType.JSON) 要求回傳的資料為 JSON格式</span></span><br><span class="line">  <span class="keyword">return</span> ContentService.createTextOutput(dataExportFormat).setMimeType(ContentService.MimeType.JSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在編輯器的工作列中，找到 <code>發布</code> 這個選項，然後選擇 <code>部屬為網頁應用程式</code><ul>
<li>Project version : 每次發布時都需要修改版本編號</li>
<li>Execute the app as: 選擇誰可以執行這個 APP</li>
<li>Who has access to the app: 選擇誰可以訪問這個 APP</li>
</ul>
</li>
<li>按下更新後，取得該 APP的網址 <code>https://script.google.com/macros/s/一連串的亂碼/exec</code></li>
</ul>
<h2 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h2><h3 id="跨網域問題"><a href="#跨網域問題" class="headerlink" title="跨網域問題"></a>跨網域問題</h3><p>為什麼需要將試算表發布為公開可檢視，是因為我們在撈取資料時，會遇到跨網域存取的問題，存放在 google的資料預設不給其他網站存取，但經過設定後，就能正常存取我們要的資料。另外，像是政府的開源資料，也常會遇到跨網域的問題，原因是<strong>同源政策</strong>，開源資料的網址在瀏覽器中可以正常讀取，但在測試用的線上程式編輯器就無法存取，因為它們無法跨網域存取資源，透過 Google Apps Script重新發布後，就能解決這個問題。</p>
<h3 id="讀取自建試算表"><a href="#讀取自建試算表" class="headerlink" title="讀取自建試算表"></a>讀取自建試算表</h3><p>可以到線上程式碼編輯器等網站測試，codePen或者其他都可以，利用 fetch語法或者套件 axios進行資料撈取。</p>
<ol>
<li><p>讀取 <code>發布至網路</code> 的試算表</p>
<ul>
<li>其網址為 <code>https://spreadsheets.google.com/feeds/list/試算表的ID/第?張工作表/public/values?alt=json</code></li>
<li>若要改回非公開，再回到 <code>發佈到網路</code> ，按下停止發布即可</li>
</ul>
</li>
<li><p>讀取 <code>部屬網頁應用程式</code></p>
<ul>
<li>不以 <code>發布至網路</code> 形式公開</li>
<li>其網址為 <code>https://script.google.com/macros/s/一連串的亂碼/exec</code></li>
<li>在網址列輸入後，會轉成另外一串亂碼網址，內容是相同的</li>
</ul>
</li>
</ol>
<h3 id="作為中繼點後讀取"><a href="#作為中繼點後讀取" class="headerlink" title="作為中繼點後讀取"></a>作為中繼點後讀取</h3><ul>
<li>新建一份試算表</li>
<li>在程式碼編輯器中，將 doGet的內容替換掉</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作為中繼站，跨網域存取開源資料</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doGet</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 取得傳入 URL</span></span><br><span class="line">  <span class="keyword">var</span> url = e.parameter.url; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 發出 GET 請求，並設定 hearder json</span></span><br><span class="line">  <span class="keyword">var</span> response = UrlFetchApp.fetch(<span class="built_in">decodeURIComponent</span>(url),&#123; </span><br><span class="line">    headers: &#123; <span class="string">&quot;Content-type&quot;</span> : <span class="string">&quot;application/json&quot;</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(response.getContentText()); <span class="comment">// 取得 json 資料</span></span><br><span class="line">  <span class="keyword">return</span> ContentService.createTextOutput(<span class="built_in">JSON</span>.stringify(data)).setMimeType(ContentService.MimeType.JSON); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>發布後取得 <code>https://script.google.com/macros/s/試算表的 ID/exec?</code></li>
<li>在這串網址後方接上開源資料的網址，<br><code>https://script.google.com/macros/s/試算表的 ID/exec?url=開源資料的網址</code></li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://letswrite.tw/google-excel-db/">Augustus 的學習筆記 - 如何用Google Excel當作資料庫</a></li>
<li><a href="https://letswrite.tw/gas-google-sheet/">Augustus 的學習筆記 - 用Google Apps Script取得Google Excel資料</a></li>
<li><a href="https://hsiangfeng.github.io/javascript/20190617/3829122039/">Ray - 使用 Google Apps Script 解決 CORS 問題</a></li>
<li><a href="https://www.oxxostudio.tw/articles/201805/backend-apps-script.html">OXXO.STUDIO - 簡易後端實作 ( Google Apps Script )</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>資料庫</category>
      </categories>
      <tags>
        <tag>Google試算表</tag>
        <tag>資料庫</tag>
      </tags>
  </entry>
  <entry>
    <title>為什麼想寫部落格?</title>
    <url>/2020/10/27/%E7%82%BA%E4%BB%80%E9%BA%BC%E6%83%B3%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<p>不知不覺就記錄了10篇文章，以往都是記錄在其他的線上筆記居多，也沒有整理過，看到可能重要的就先寫進再說。</p>
<p>雖然線上筆記服務也是可以公開分享，Medium也可以寫文章，但總覺得它對於程式碼區塊的顏色看不順眼，HackMD則變成了快速筆記用，最終還是採取建立一個技術性質的部落格。</p>
<p>而寫文的目的是重新記錄自己學過的技能，不管它是否能幫我轉職，取之於社會用之於社會，於是這個部落格就誕生了，謝謝參考來源的作者不吝分享經驗。</p>
]]></content>
      <categories>
        <category>閒聊</category>
      </categories>
  </entry>
  <entry>
    <title>記錄自己的成長，那怕是1%也好</title>
    <url>/2020/10/16/%E8%A8%98%E9%8C%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%88%90%E9%95%B7%EF%BC%8C%E9%82%A3%E6%80%95%E6%98%AF1-%E4%B9%9F%E5%A5%BD/</url>
    <content><![CDATA[<p>利用 Hexo寫技術部落格，那怕是第一篇，或者只有一篇，只怕自己停佇不前。</p>
]]></content>
      <categories>
        <category>閒聊</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo教學(六) 文章標籤與分類</title>
    <url>/2020/10/26/hexo%E6%95%99%E5%AD%B8/Hexo%E6%95%99%E5%AD%B8(%E5%85%AD)%E6%96%87%E7%AB%A0%E6%A8%99%E7%B1%A4%E8%88%87%E5%88%86%E9%A1%9E/</url>
    <content><![CDATA[<p>先前我們學到如何新增一篇文章，這篇會說明如何將文章上標籤與分類管理。</p>
<h2 id="建立分類"><a href="#建立分類" class="headerlink" title="建立分類"></a>建立分類</h2><ol>
<li>輸入 <code>hexo new page &#39;categories&#39;</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source中會看到 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories</li>
<li>修改 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories中的 index.md檔案，插入 <code>type: &quot;categories&quot;</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-22 11:16:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>在 _post內的其中一份檔案插入 <code>categories: hexo教學</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章標題</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>重新產生靜態檔案，可以在導覽列看到多了一個分類分頁</li>
</ol>
<h2 id="建立標籤"><a href="#建立標籤" class="headerlink" title="建立標籤"></a>建立標籤</h2><p>與分類的步驟一樣，但內容改變。</p>
<ol>
<li>輸入 <code>hexo new page &#39;tags&#39;</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source中會看到 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> categories</li>
<li>修改 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> tags index.md檔案，插入 <code>type: &quot;tags&quot;</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-22 11:16:05</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>在 _post內的其中一份檔案插入 <code>categories: hexo教學</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章標題</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
若需要多個標籤，可以這樣輸入<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">教學文</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>重新產生靜態檔案，可以在導覽列看到多了一個標籤分頁</li>
</ol>
<p>若沒看到分頁出現，可能是 Next主題的設定沒有開啟，可以在 Next主題的設定檔中開啟，路徑為 themes\next_config.yml，</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || fa fa-home</span><br><span class="line">  <span class="meta">#about: /about/ || fa fa-user</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || fa fa-tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || fa fa-th</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || fa fa-archive</span><br><span class="line">  <span class="meta"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="meta"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="meta"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(一) 使用 Hexo寫部落格</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%B8%80)%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E4%BD%BF%E7%94%A8Hexo%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="為什麼要使用-Hexo寫部落格"><a href="#為什麼要使用-Hexo寫部落格" class="headerlink" title="為什麼要使用 Hexo寫部落格?"></a>為什麼要使用 Hexo寫部落格?</h2><p>現在有很多線上服務都能當成部落格，不管寫在 github、medium或者 wordpress等等，同樣是寫文章，心得也好，技術文也罷，學著使用 markdown寫文，最起碼自己的電腦有初始檔案，不怕線上服務突然關閉或者改變使用條款，而且只要有網頁伺服器，就能發布自己的部落格。</p>
<h2 id="教學連結"><a href="#教學連結" class="headerlink" title="教學連結"></a>教學連結</h2><p>後續 hexo教學會說明這些主題並建立連結 :</p>
<ul>
<li>環境建立與安裝</li>
<li>匯入主題 (themes)</li>
<li>部屬到網頁 (使用 github page)</li>
<li>分類與標籤</li>
<li>Next主題相關設定 - 開啟數學符號以及更改字體</li>
</ul>
<h2 id="撰寫工具與線上服務"><a href="#撰寫工具與線上服務" class="headerlink" title="撰寫工具與線上服務"></a>撰寫工具與線上服務</h2><p>我們會使用到的軟體或服務如下，可以先點連結下載安裝或者先建立帳號</p>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a> <ul>
<li>程式編輯器，我們會使用 VScode來編輯  hexo的資源</li>
</ul>
</li>
<li><a href="https://nodejs.org/en/">node.js</a><ul>
<li>後續安裝 hexo環境會用到，LTS是穩定的版本，Current是最新的，推薦使用 <strong>LTS版本</strong></li>
</ul>
</li>
<li><a href="https://github.com/">github.com</a><ul>
<li>程式碼版控，其中一項服務可以用來發布 hexo</li>
</ul>
</li>
<li><a href="https://hackmd.io/">HackMD</a><ul>
<li>線上筆記之一， hexo的撰寫方式為 markdown，使用 HackMD的服務可以快速編輯與即時預覽，不怕文章編輯到一半當掉。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(三) 主題匯入</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%B8%89)%E4%B8%BB%E9%A1%8C%E5%8C%AF%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Hexo檔案結構"><a href="#Hexo檔案結構" class="headerlink" title="Ｈexo檔案結構"></a>Ｈexo檔案結構</h2><p>Hexo裡面會有一些內層資料夾以及一些單一檔案，敘述如下 :<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> node_modules $\rightarrow$ node.js套件資源包，通常此資料夾容量很大<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> public $\rightarrow$ 經由 <code>hexo generate</code> 指令所發布的靜態檔案都在這<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> scaffolds $\rightarrow$ 當我們新增一篇文章或頁面時，會根據這裡的模板檔案進行初始化<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source $\rightarrow$ 新增的文章與頁面都會在這<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _posts $\rightarrow$ 存放 <code>hexo new post/draft/page &#39;文章標題&#39;</code> 指令新增的文章<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> themes $\rightarrow$ hexo主題都會放在這裡<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> landscape  $\rightarrow$ 預設主題<br>├─ _config.yml  $\rightarrow$ hexo的設定檔，稍後會到這裡設定<br>├─ .gitignore $\rightarrow$ 會被 git忽略的資料夾或檔案在這裡設定<br>├─ package.json $\rightarrow$ 與 npm相關，管理會用到的套件版本，可修改版本來使用<br>└─  package-lock.json $\rightarrow$ 與 npm相關，此為自動產生，不必修改</p>
<p>備註 : 可以在  _posts 內增加資料夾進行文章分類</p>
<h2 id="匯入主題"><a href="#匯入主題" class="headerlink" title="匯入主題"></a>匯入主題</h2><p>官方預設的主題會放在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> themes中，主題名稱是 landscape，而 Hexo的主題可以自行製作，也可以到<a href="https://hexo.io/themes/">這邊</a>尋找喜歡的，這裡分享如以下 :</p>
<ul>
<li>hueman<ul>
<li><code>git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman</code></li>
</ul>
</li>
<li>NexT<ul>
<li><a href="https://github.com/next-theme/hexo-theme-next.git">版本 v8 </a></li>
<li><code>git clone https://github.com/next-theme/hexo-theme-next.git themes/next</code></li>
</ul>
</li>
</ul>
<p>那麼要如何將主題匯入呢?<br>上面那串指令就是將主題從網路上下載一份回來，並存放在指定的位置，將它簡化就是 <code>git clone 主題存放網址 hexo指定的資料夾位置</code>，記得要在建立好的<code>桌面\新增資料夾\hexoblog</code>中輸入指令，路徑位置為舉例，請根據有上述那些資料夾的 hexo位置輸入。</p>
<h3 id="NexT主題設定"><a href="#NexT主題設定" class="headerlink" title="NexT主題設定"></a>NexT主題設定</h3><p>由於自己選擇了 NexT主題匯入，<a href="https://hsuan777.github.io/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8Next%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A/">這邊</a>有 NexT的設定與說明。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10238330">Ray - (4) 試著學 Hexo - 認識 Hexo 目錄結構</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10246631">Ray - (17) 試著學 Hexo - NexT 主題篇 - NexT</a></li>
<li><a href="https://ed521.github.io/2020/05/hexo-folder-theme/">瑪利歐 - Hexo 資料夾/檔案架構、佈景主題修改介紹</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(二) 環境建立與安裝 hexo</title>
    <url>/2020/10/22/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%BA%8C)%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E5%AE%89%E8%A3%9Dhexo/</url>
    <content><![CDATA[<h2 id="基礎環境建立"><a href="#基礎環境建立" class="headerlink" title="基礎環境建立"></a>基礎環境建立</h2><ol>
<li>開啟 VScode後，按下快捷鍵 <code>ctrl+~</code>，會打開終端機</li>
<li>輸入 <code>node -v</code><ul>
<li>確認 node.js，若成功會出現版本編號</li>
</ul>
</li>
<li>輸入 <code>npm -v</code> <ul>
<li>確認 npm，若成功會出現版本編號</li>
</ul>
</li>
<li>輸入 <code>npm install -g hexo-cli</code><ul>
<li>正式安裝 hexo</li>
</ul>
</li>
</ol>
<h3 id="node-js與-npm"><a href="#node-js與-npm" class="headerlink" title="node.js與 npm"></a>node.js與 npm</h3><p>自己對它們的了解， node.js是一個執行 JavaScript的環境，如同要運作 python時必須安裝 python的執行檔，npm則是一個線上的套件資源庫，可以輸入指令 <code>npm install 套件名稱</code> 來安裝額外套件，可以在網路上搜尋這兩個<a href="https://www.google.com/search?ei=j06SX_bNB5G9mAXOkoSgBw&q=node.js+npm&oq=node.js+npm&gs_lcp=CgZwc3ktYWIQAzICCAAyAggAMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjIGCAAQBxAeMgYIABAHEB4yBggAEAcQHjoFCAAQzQJQzGFYu25glHJoAHAAeACAAYoBiAHcApIBAzMuMZgBAKABAaoBB2d3cy13aXrAAQE&sclient=psy-ab&ved=0ahUKEwi20d2548nsAhWRHqYKHU4JAXQQ4dUDCA0&uact=5">關鍵字</a>，會有更多開發者的說明。</p>
<h2 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h2><p>上一階段已安裝完 hexo所需的基礎環境，接著要在電腦中新增一個空的資料夾來存放 hexo的檔案。</p>
<ol>
<li>新增資料夾<ul>
<li>可以直接在桌面上新增一個資料夾，接著將它拖曳至 VScode，終端機的路徑就會是該資料夾的路徑了</li>
<li>或者輸入終端機指令來新增一個空的資料夾並進入該資料夾中</li>
</ul>
</li>
<li>輸入 <code>hexo init 自訂部落格名稱</code><ul>
<li>為了方便說明自訂部落格名稱簡化為 hexoblog</li>
<li>確認終端機路徑已在新建立的空資料夾中，我們要在這個資料夾中下載 hexo的初始檔案，也就是 hexo的初始化</li>
<li>資料夾名稱可以跟部落格名稱不同，可以在 hexo的設定檔中更改部落格名稱</li>
<li>若只輸入 <code>hexo init</code>，很可能會遇到安裝錯誤</li>
</ul>
</li>
<li>確認 hexo初始資源<ul>
<li>此時資料夾結構應該會是 <code>桌面\新增資料夾\hexobolg</code></li>
<li>輸入 <code>cd hexobolg</code>，路徑會從 <code>桌面桌面\新增資料夾</code> 變更為 <code>桌面桌面\新增資料夾\hexobolg</code></li>
<li>可以在 VScode的左邊檔案視窗檢查，確認 hexobolg的資料夾已有 hexo的初始相關檔案</li>
</ul>
</li>
</ol>
<p>舉個範例，若在桌面上新增了一個資料夾，那麼最終資料夾結構應該會是 <code>桌面\新增資料夾\hexoblog</code></p>
<h2 id="修改基礎設定"><a href="#修改基礎設定" class="headerlink" title="修改基礎設定"></a>修改基礎設定</h2><p>剛下載好的 hexo有些設定是預設的，所以我們要修改成自己的。<br>找到 <code>hexoblog\_config.yml</code>這隻檔案，可以先修改以下資訊</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attribute">title</span>: Help One Percent</span><br><span class="line"><span class="attribute">subtitle</span>: &#x27;遺忘x回想x自動化&#x27;</span><br><span class="line"><span class="attribute">description</span>: &#x27;哪怕是1%也好，只怕自己停佇不前&#x27;</span><br><span class="line"><span class="attribute">keywords</span>: 前端,CSS,JavaScript,Vue.js,git,演算法入門</span><br><span class="line"><span class="attribute">author</span>: Vic</span><br><span class="line"><span class="attribute">language</span>: zh-TW</span><br><span class="line"><span class="attribute">timezone</span>: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="啟動-hexo"><a href="#啟動-hexo" class="headerlink" title="啟動 hexo"></a>啟動 hexo</h2><p>接下來，我們可以先使用預設主題模擬上線情況。</p>
<ol>
<li>輸入 <code>hexo generate</code><ul>
<li>會產生靜態檔案</li>
</ul>
</li>
<li>輸入 <code>hexo server</code><ul>
<li>啟動 hexo內建的模擬網頁伺服器</li>
</ul>
</li>
<li>在網址列輸入提供的網址，預設會是 <code>http://localhost:4000</code></li>
</ol>
<p>若成功看到預設主題以及第一篇文章標題 “Hello World”，恭喜你已經完成一半了! </p>
<p>接下來我們要新增一篇文章並調整主題以及其他設定。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10236936">Ray - (3)試著學 Hexo - 如何安裝 Hexo</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10238330">Ray - (4)試著學 Hexo - 認識 Hexo 目錄結構</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學(五) 部署文章至 Github Page</title>
    <url>/2020/10/26/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E4%BA%94)%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0%E8%87%B3%20Github%20Page/</url>
    <content><![CDATA[<h2 id="建立-github資料庫"><a href="#建立-github資料庫" class="headerlink" title="建立 github資料庫"></a>建立 github資料庫</h2><p>登入 github.com後，新增一個資料庫做為 hexo的儲存空間，我們會使用這個資料庫發布部落格。</p>
<ol>
<li>右上方點擊 New repository</li>
<li>在 Repository name欄位中輸入 <code>你的github帳號.github.io</code></li>
<li>選擇 Public</li>
<li>點擊 Creat repository</li>
<li>點擊此資料庫的 <strong>Setting</strong></li>
<li>在 Setting的頁面中找到名為 GitHub Pages的標題</li>
<li>在 GitHub Pages的選項中，找到子標題 Source，將第一個選項改為 master</li>
<li>選擇 master後，會發現上面一則通知，它會是<br>Your site is published at https://你的github帳號.github.io</li>
</ol>
<h2 id="修改-hexo設定檔"><a href="#修改-hexo設定檔" class="headerlink" title="修改 hexo設定檔"></a>修改 hexo設定檔</h2><p>建立好 github的資料庫後，接著我們回到 hexo底下的 <code>_config.yml</code>，我們要修改發布時會用到的資訊。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line">url: https:<span class="regexp">//</span>你的github帳號.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:<span class="regexp">//gi</span>thub.com<span class="regexp">/你的github帳號/</span>你的github帳號.github.io.git </span><br><span class="line">  branch: master </span><br><span class="line">  message: <span class="string">&#x27;hexoblog&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="部屬-Deploy"><a href="#部屬-Deploy" class="headerlink" title="部屬 (Deploy)"></a>部屬 (Deploy)</h2><p>完成上述兩個部分後，讓我們重新產生 hexo的靜態檔案，就能將寫好的文章上傳了。<br>這裡還需要再輸入一個指令，<code>npm install --save hexo-deployer-git</code>，這樣才能將 hexo一鍵部屬到 github上。</p>
<ol>
<li>輸入 <code>hexo clean</code>，可縮寫 <code>hexo cl</code></li>
<li>輸入 <code>hexo generate</code>，可縮寫 <code>hexo g</code></li>
<li>輸入 <code>hexo server</code>，可縮寫 <code>hexo s</code></li>
<li>輸入 <code>hexo deploy</code>，正式將文章上傳至網路空間</li>
<li>在網址列輸入 https://你的github帳號.github.io，看是否成功</li>
</ol>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10242893">Ray - 試著學 Hexo - 部署你的第一個部落格</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo教學(四) 新增文章與常用指令</title>
    <url>/2020/10/23/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8(%E5%9B%9B)%E6%96%B0%E5%A2%9E%E6%96%87%E7%AB%A0%E8%88%87%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>在上一篇匯入主題後，這篇我們來新增一篇文章，輸入指令後，會在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _post 中看到我們新建立的檔案。<br>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _post<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ *.md</p>
<ul>
<li>輸入 <code>hexo new &#39;文章標題&#39;</code></li>
<li>檔案格式為 *.md</li>
<li>寫法為 markdown</li>
</ul>
<h3 id="文章與樣板-scaffolds"><a href="#文章與樣板-scaffolds" class="headerlink" title="文章與樣板 scaffolds"></a>文章與樣板 scaffolds</h3><p>├─ <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ _drafts.md<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ _page.md<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─  _post.md<br>通常 hexo新增文章時，預設利用 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> _source內的 _post.md新增一篇文章，其三份檔案的功能如下 :</p>
<ul>
<li>_drafts.md，指令為 <code>hexo new drafts &#39;文章標題&#39;</code>，用於存放草稿且不會產生靜態檔案。</li>
<li>_page.md，指令為 <code>hexo new page &#39;文章標題&#39;</code>，新開一個導覽頁面，像是關於我、歸檔以及標籤等網站分頁。</li>
<li>_post.md，指令為 <code>hexo new post &#39;文章標題&#39;</code>，用於新增文章且會產生靜態檔案。</li>
</ul>
<p>可以在這些樣板檔案中規劃需要的標籤或者分類以及其他的資訊，如以下區塊 :</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>標籤與分類，會在其他篇說明。</p>
<h2 id="常見-markdown語法"><a href="#常見-markdown語法" class="headerlink" title="常見 markdown語法"></a>常見 markdown語法</h2><p>Markdown語法有非常多，這邊例舉幾個常用語法。</p>
<h3 id="標題類"><a href="#標題類" class="headerlink" title="標題類"></a>標題類</h3><table>
<thead>
<tr>
<th>符號</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>h1標題~h6標題</td>
</tr>
<tr>
<td>######</td>
<td>h1標題~h6標題</td>
</tr>
<tr>
<td>- + 空格</td>
<td>無序清單</td>
</tr>
<tr>
<td>1. + 空格</td>
<td>有序清單</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>引用</td>
</tr>
<tr>
<td><code>``</code></td>
<td>程式碼註解</td>
</tr>
<tr>
<td><code>```</code></td>
<td>程式碼區塊(上面三個下面三個)</td>
</tr>
</tbody></table>
<h3 id="文字類"><a href="#文字類" class="headerlink" title="文字類"></a>文字類</h3><table>
<thead>
<tr>
<th>符號</th>
<th>功能</th>
<th>實際效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>**文字**</code></td>
<td>粗體</td>
<td><strong>文字</strong></td>
</tr>
<tr>
<td><code>*文字*</code></td>
<td>斜體</td>
<td><em>文字</em></td>
</tr>
<tr>
<td><code>&lt;u&gt;文字&lt;u&gt;</code></td>
<td>底線</td>
<td><u>文字<u></td>
</tr>
<tr>
<td><code>~~文字~~</code></td>
<td>刪節線</td>
<td><del>文字</del></td>
</tr>
<tr>
<td><code>&lt;font color=#FF0000&gt;紅色&lt;/font&gt;</code></td>
<td>文字顏色</td>
<td><font color=#FF0000>紅色</font></td>
</tr>
<tr>
<td><code>[連結文字](網址)</code></td>
<td>超連結文字</td>
<td><a href="%E7%B6%B2%E5%9D%80">連結文字</a></td>
</tr>
<tr>
<td><code>![圖片文字](網址)</code></td>
<td>圖片</td>
<td><img src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="Google"></td>
</tr>
</tbody></table>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// :---  靠左對齊</span><br><span class="line">// ---:  靠右對齊</span><br><span class="line">// :---: 置中對齊</span><br><span class="line">|<span class="string"> 標題一 </span>|<span class="string"> 標題二 </span>|<span class="string"> 標題三 </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> -------- </span>|<span class="string">-------</span>|</span><br><span class="line">|<span class="string"> 文字 </span>|<span class="string"> 文字 </span>|<span class="string"> 文字</span></span><br></pre></td></tr></table></figure>

<h2 id="hexo常用指令"><a href="#hexo常用指令" class="headerlink" title="hexo常用指令"></a>hexo常用指令</h2><p>之後會輸入以下數次，其實多打幾次就會記住了。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>hexo generate</code></td>
<td>產生靜態檔案</td>
</tr>
<tr>
<td><code>hexo server</code></td>
<td>啟動模擬網頁伺服器</td>
</tr>
<tr>
<td><code>hexo clean</code></td>
<td>刪除編譯完成的靜態檔案</td>
</tr>
<tr>
<td><code>hexo deploy</code></td>
<td>部屬檔案至 github page</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學 404頁面</title>
    <url>/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8404/</url>
    <content><![CDATA[<h2 id="建立-404頁面"><a href="#建立-404頁面" class="headerlink" title="建立 404頁面"></a>建立 404頁面</h2><ol>
<li>輸入 <code>hexo new page 404</code></li>
<li>在 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span> source\404\index.md 增加以下資訊<ul>
<li>comments，若之後有開啟評論功能，在這邊先將它關閉</li>
<li>permalink，網站中的固定連結<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="number">404</span> <span class="bullet">-</span> <span class="string">您似乎來到不對的地方~</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-10-27 13:45:41</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">/404</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>增加頁面說明文字。<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 您要找的網頁不存在。</span></span><br><span class="line"></span><br><span class="line">很抱歉，您目前存取的頁面不存在。</span><br><span class="line"></span><br><span class="line">請點擊[<span class="string">這裡</span>](<span class="link">https://您的帳號.github.io/</span>)回首頁。</span><br></pre></td></tr></table></figure>
建立好上述資訊後重新建立靜態檔案，github的預設 404頁面就會使用我們新建的 404頁面了。</li>
</ol>
<p>另外，在 github中有兩種方式都能讀取到 404頁面，</p>
<ul>
<li>若 404路徑為 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span>source\404\index.md<ul>
<li>permalink就設定為 <code>permalink: /404</code></li>
</ul>
</li>
<li>若 404路徑為 <span class="github-emoji" alias="file_folder" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c1.png?v8">&#x1f4c1;</span>source\404.md <ul>
<li>permalink就設定為 <code>permalink: /404.html</code> </li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/creating-a-custom-404-page-for-your-github-pages-site">Creating a custom 404 page for your GitHub Pages site</a></li>
<li><a href="https://hexo.io/zh-tw/docs/permalinks.html">Hexo - Permalinks</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10249685">Ray - 試著學 Hexo - SEO 篇 - 新增你的 404 頁面</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教學 Next主題設定與頁面功能(Ver. 8)</title>
    <url>/2020/10/27/hexo%E6%95%99%E5%AD%B8/hexo%E6%95%99%E5%AD%B8Next%E4%B8%BB%E9%A1%8C%E8%A8%AD%E5%AE%9A/</url>
    <content><![CDATA[<p>由於自己選擇了 NexT主題匯入，這邊就以 NexT的設定做介紹。<br>請找到 <code>themes/next/_config.yml</code> 這隻檔案。</p>
<h2 id="全域設定"><a href="#全域設定" class="headerlink" title="全域設定"></a>全域設定</h2><h3 id="菜單導覽"><a href="#菜單導覽" class="headerlink" title="菜單導覽"></a>菜單導覽</h3><p>可以根據實際需求開啟，<code>#</code> 移除為關閉，反之則開。</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment"># about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h3 id="搜尋"><a href="#搜尋" class="headerlink" title="搜尋"></a>搜尋</h3><p>請輸入以下指令，會開始安裝額外套件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>接著搜尋 local_search的設定，將它設為 true</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="字體"><a href="#字體" class="headerlink" title="字體"></a>字體</h3><p>修改 Next主題的字體，預設為 Google font的字體資源。</p>
<ul>
<li>font $\rightarrow$ 記得開啟</li>
<li>font &gt; host $\rightarrow$ 若有其他字體資源，可將網址放這</li>
<li>global $\rightarrow$ 網站文字全部修改</li>
<li>其餘部分均能修改成不同字體</li>
</ul>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># family: Lato</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">&quot;Noto Sans TC&quot;</span></span><br><span class="line">    <span class="attr">size:</span> </span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">  <span class="attr">posts:</span></span><br></pre></td></tr></table></figure>

<h3 id="閱讀全文-More"><a href="#閱讀全文-More" class="headerlink" title="閱讀全文 More"></a>閱讀全文 More</h3><div class="tabs" id="閱讀全文"><ul class="nav-tabs"><li class="tab"><a href="#閱讀全文-1">1. 手動截斷</a></li><li class="tab active"><a href="#閱讀全文-2">2. 加入 description</a></li></ul><div class="tab-content"><div class="tab-pane" id="閱讀全文-1"><p>在文章中某的地方加入 <code>&lt;!--more--&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">文字文字文字文字文字文字文字<span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="閱讀全文-2"><p>在檔案 header部分加上 description，會根據其內容呈現。</p>
<figure class="highlight yaml"><figcaption><span>source/_posts/頁面.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="撰寫相關功能"><a href="#撰寫相關功能" class="headerlink" title="撰寫相關功能"></a>撰寫相關功能</h2><h3 id="程式碼區塊"><a href="#程式碼區塊" class="headerlink" title="程式碼區塊"></a>程式碼區塊</h3><h4 id="區塊複製"><a href="#區塊複製" class="headerlink" title="區塊複製"></a>區塊複製</h4><figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="區塊主題"><a href="#區塊主題" class="headerlink" title="區塊主題"></a>區塊主題</h4><p><a href="https://theme-next.js.org/highlight/">主題預覽</a></p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># light: default</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line"><span class="attr">prism:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br></pre></td></tr></table></figure>

<h4 id="區塊標題"><a href="#區塊標題" class="headerlink" title="區塊標題"></a>區塊標題</h4><p>標題前方可以加上該程式碼為何種語言，<br>例如，.yal為 yaml，.js 為 javascript</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">```yaml 標題文字</span><br><span class="line">title: </span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">``` ```</span><br></pre></td></tr></table></figure>

<h3 id="數學符號"><a href="#數學符號" class="headerlink" title="數學符號"></a>數學符號</h3><table>
<thead>
<tr>
<th>功能名稱</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>every_page</code></td>
<td>是否讓每一頁都開啟數學符號功能</td>
</tr>
<tr>
<td><code>mathjax</code></td>
<td>是否讓 mathjax寫在檔案開頭才開啟數學符號功能</td>
</tr>
</tbody></table>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>回到撰寫頁面</p>
<figure class="highlight yaml"><figcaption><span>source/_post/頁面.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo教學</span> <span class="string">Next主題</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo教學</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Next主題相關設定</span> <span class="bullet">-</span> <span class="string">開啟數學符號以及更改字體</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="內容分頁-tabs"><a href="#內容分頁-tabs" class="headerlink" title="內容分頁 tabs"></a>內容分頁 tabs</h3><p>預設就能使用，設定為 true時，切換時較為平滑</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tabs tag</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>回到頁面撰寫時，加入以下字串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 區塊標題, 預設顯示區塊索引值 %&#125;</span><br><span class="line">&lt;!-- tab 可單獨寫分頁標題 --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>用上面的範例可以這樣寫 :</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> 閱讀全文, 2 %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab 手動截斷--&gt;</span></span></span><br><span class="line"><span class="xml">在文章中某的地方加入 `<span class="comment">&lt;!--more--&gt;</span>`</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab 加入 description--&gt;</span></span></span><br><span class="line"><span class="xml">在檔案 header部分加上 description，會根據其內容呈現。</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>若 <code>&lt;!-- tab 手動截斷--&gt;</code> 不加上該分頁標題，只有單純 <code>&lt;!-- tab --&gt;</code>，<br>則會根據區塊標題的文字自動加上索引值然後在分頁標題上顯示 <code>分頁標題 1</code> <code>分頁標題 2</code>。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> First unique name %&#125;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 1**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 2**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**這是分頁 3**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>
<p>自動加入分頁標題 : </p>
<div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1">First unique name 1</a></li><li class="tab"><a href="#first-unique-name-2">First unique name 2</a></li><li class="tab"><a href="#first-unique-name-3">First unique name 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>這是分頁 1</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>這是分頁 2</strong></p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>這是分頁 3</strong></p></div></div></div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="關閉-Powered-by-Hexo-amp-NexT"><a href="#關閉-Powered-by-Hexo-amp-NexT" class="headerlink" title="關閉 Powered by Hexo &amp; NexT"></a>關閉 Powered by Hexo &amp; NexT</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 Powered可以自由關閉，</p>
<h3 id="版權宣告"><a href="#版權宣告" class="headerlink" title="版權宣告"></a>版權宣告</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 copyright，可以加入版權宣告的文字敘述。</p>
<h3 id="footer-icon"><a href="#footer-icon" class="headerlink" title="footer icon"></a>footer icon</h3><p>在 <code>themes/next/_config.yml</code>中，尋找 “# Icon name in Font Awesome.” ，可以在 <a href="https://fontawesome.com/icons">fontawesome</a>找到喜歡的 icon，將 “name”的文字更換即可，當然也可以修改 “animated”與 “color”。</p>
<h2 id="後續功能"><a href="#後續功能" class="headerlink" title="後續功能"></a>後續功能</h2><ul>
<li>摺疊</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://theme-next.js.org/docs/third-party-services/math-equations">NexT說明 - math-equations</a></li>
<li><a href="https://theme-next.js.org/docs/tag-plugins/tabs.html">NexT說明 - tabs</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10248682">Ray - 試著學 Hexo - NexT 主題篇 - NexT 還有哪些設定？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10248214">Ray - 試著學 Hexo - 試著學 Hexo - NexT 主題篇 - 可以安裝的套件 </a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>hexo教學</category>
      </categories>
      <tags>
        <tag>hexo教學</tag>
        <tag>hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 箭頭函式與this(上)</title>
    <url>/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="箭頭函式-Arrow-functions"><a href="#箭頭函式-Arrow-functions" class="headerlink" title="箭頭函式 (Arrow functions)"></a>箭頭函式 (Arrow functions)</h2><p>與一般函式相比，寫法更加簡潔，也避免了某些問題。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般函式寫法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為具名函式 - 函式陳述式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為匿名函式 - 函式表達式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭頭函式</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;此為箭頭函式寫法。&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若函式只有單一變數，參數括號可以簡化</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  str = <span class="string">&#x27;簡化參數括號&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若函式內只有單一陳述行，大括號可以簡化，但沒有參數時，括號必須存在</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;此為箭頭函式簡易寫法。&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="箭頭函式與一般函式的差異"><a href="#箭頭函式與一般函式的差異" class="headerlink" title="箭頭函式與一般函式的差異"></a>箭頭函式與一般函式的差異</h3><p>箭頭函式除了寫法簡潔之外，它跟一般函式有甚麼差異? 每當搜尋相關介紹時，總會說明它沒有這些 : </p>
<ul>
<li><code>this</code></li>
<li><code>arguments</code> </li>
<li><code>call()</code></li>
<li><code>apply()</code></li>
<li><code>bind()</code></li>
</ul>
<p>而這些到底是甚麼? 為什麼那三個內建函式又是甚麼? 為什麼它們看起來很陌生? 在下集會來介紹，在上集中會先介紹 <code>this</code>。</p>
<p>先簡易說明一下，<code>call()</code>、<code>apply()</code>、<code>bind()</code> 這三種 JS內建函式，可以影響 <code>this</code> 的運作，若使用箭頭函式的話，由於 ES6的規則，連帶的那三個函式也跟著無法使用。<br>而 <code>arguments</code>，它為一般函式的內建參數，在箭頭函式中無此內建參數可運用，但是可以改用 ES6的其餘參數來達到同樣效果。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>看到箭頭函式的介紹時，常會看到一句話，箭頭函式沒有自己的 <code>this</code>，而 <code>this</code> 從何而來，又指向誰，為什麼會用到它? </p>
<h3 id="this是甚麼"><a href="#this是甚麼" class="headerlink" title="this是甚麼 ?"></a>this是甚麼 ?</h3><ul>
<li>this 是 JavaScript的內建關鍵字之一</li>
<li>通常會用在函式或物件中，來呼叫自身的擁有的屬性或值等等…</li>
</ul>
<h3 id="this從何而來"><a href="#this從何而來" class="headerlink" title="this從何而來 ?"></a>this從何而來 ?</h3><p>先來看個範例 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>當我們將瀏覽器打開時，就已經建立好全域環境與執行環境，而程式碼就是寫在執行環境中，而 <code>this</code> 與全域環境一起被建立。</p>
<ul>
<li>全域環境</li>
<li><code>this</code></li>
<li>執行環境</li>
</ul>
<p>當我們要呼叫 a這個變數時，由上述範例可以知道，有三種呼叫變數 a的方式 :</p>
<ul>
<li>直接呼叫</li>
<li>透過全域物件呼叫</li>
<li>透過 JS內建關鍵字 <code>this</code> 呼叫</li>
</ul>
<p>變數 a是由 var宣告的，而它的執行環境在全域環境中，於是變數 a就被建立在全域環境，接著就能透過全域物件 window找到它。</p>
<h3 id="this指向誰"><a href="#this指向誰" class="headerlink" title="this指向誰 ?"></a>this指向誰 ?</h3><p>通常我們寫程式碼時，習慣在全域環境下作業，而 <code>this</code> 在呼叫自身時，<strong>必須留意在哪個環境被呼叫，而不看在哪裡被使用</strong>，像是以下這些例子 :</p>
<ul>
<li>簡易呼叫函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全域的環境下執行函式，`this`會呼叫全域下的變數</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域阿婆&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nameFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;漂亮阿姨&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">nameFn() <span class="comment">// &#x27;全域阿婆&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>物件中呼叫函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全域的環境下執行物件中的函式，`this`則指向物件本身</span></span><br><span class="line"><span class="keyword">const</span> obj =&#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn()&#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// &#x27;小杰&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>物件裡呼叫函式並執行函式中的函式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域阿婆&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn()&#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    callFn2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// 相當於直接執行 callFn2() -&gt; &#x27;全域阿婆&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="為什麼會用-this"><a href="#為什麼會用-this" class="headerlink" title="為什麼會用 this ?"></a>為什麼會用 this ?</h3><p>在 <code>this</code> 一開始有提到，它可以用在函式或物件中，來呼叫自身的擁有的屬性或值，來看以下例子 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personA = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">number</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;number&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">personA.sayHello(personA.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personB = &#123;</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">personB.sayHello()</span><br></pre></td></tr></table></figure>
<p>使用 <code>this</code> 可以讓程式碼簡化不少。</p>
<h2 id="箭頭函式與-this"><a href="#箭頭函式與-this" class="headerlink" title="箭頭函式與 this"></a>箭頭函式與 this</h2><p>上述範例中，物件裡呼叫函式並執行函式中的函式，<code>this</code> 會指向全域，而我們可以使用箭頭函式來解決這樣的問題，因為 : </p>
<ul>
<li>箭頭函式沒有自己的 <code>this</code></li>
<li>當箭頭函式中使用 <code>this</code>時，它會往上一層尋找</li>
<li>也就是說，<strong>在哪邊被使用，它就會往上一層尋找，而不看環境</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;全域阿婆&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  name:<span class="string">&#x27;小杰&#x27;</span>,</span><br><span class="line">  callFn () &#123; <span class="comment">// 物件內函式縮寫</span></span><br><span class="line">    <span class="keyword">const</span> callFn2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    callFn2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.callFn(); <span class="comment">// &#x27;小杰&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h2><ul>
<li>箭頭函式怎麼寫 ?</li>
<li>如何知道箭頭函式沒有自己的 <code>this</code> ?</li>
<li>甚麼時候會用到 <code>this</code> ?</li>
<li><code>this</code> 在不同地方會指向誰 ?<ul>
<li>在全域環境下，若創造一個箭頭函式並使用了 <code>this</code> ，它會指向誰 ?</li>
<li>在物件中新增了一個函式並使用了 <code>this</code> ，最後在全域環境下呼叫物件內的函式，它會指向誰 ?</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/schaoss-blog/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%8D%81-10-js-%E4%B8%80%E8%88%AC%E5%87%BD%E5%BC%8F%E8%88%87%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E7%9A%84%E5%B7%AE%E7%95%B0-32ce9455ff1a">Schaos - 前端三十｜10. [JS] 一般函式與箭頭函式的差異？</a></li>
<li><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/">胡立 - 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10218937">Mooji - JS 原力覺醒 Day07 - 陳述式 表達式</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/">卡斯伯 - 鐵人賽：箭頭函式 (Arrow functions)</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN - 箭頭函式</a></li>
<li>六角學院 - JS核心篇</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 箭頭函式與this(下) - call、apply、bind</title>
    <url>/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="函式的內建方法與關鍵字"><a href="#函式的內建方法與關鍵字" class="headerlink" title="函式的內建方法與關鍵字"></a>函式的內建方法與關鍵字</h2><p>在箭頭函式與 this(上)中提到，箭頭函式沒有這些方式可以用 : </p>
<ul>
<li><code>this</code></li>
<li><code>arguments</code> </li>
<li><code>call()</code></li>
<li><code>apply()</code></li>
<li><code>bind()</code></li>
</ul>
<p>這篇我們要來看這些東西原本是怎麼運作的。</p>
<h3 id="關鍵字-this"><a href="#關鍵字-this" class="headerlink" title="關鍵字 this"></a>關鍵字 this</h3><p>複習一下 <code>this</code> 的運作 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  whoAmI: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，今年<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>歲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.whoAmI()</span><br><span class="line"><span class="comment">// 由於是在物件呼叫此函式的，所以往上一層尋找時(非箭頭函式)，會找到此物件的屬性值</span></span><br></pre></td></tr></table></figure>

<h3 id="關鍵字-arguments"><a href="#關鍵字-arguments" class="headerlink" title="關鍵字 arguments"></a>關鍵字 arguments</h3><ul>
<li>一般函式內建的關鍵字之一</li>
<li>可以將傳入的參數值抓取出來形成一個類陣列<strong>物件</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="內建函式-call、apply、bind的共通點"><a href="#內建函式-call、apply、bind的共通點" class="headerlink" title="內建函式 call、apply、bind的共通點"></a>內建函式 call、apply、bind的共通點</h3><ul>
<li>JS的內建函式</li>
<li>它們都與 <code>this</code> 有所關聯</li>
<li>不需要在函式中自訂參數就能將變數塞進 <code>this</code></li>
<li>若有多個值，函式的第一個參數位置為 <code>this</code></li>
<li>也就是說<code>(this, 參數1, 參數2, 以此類推)</code></li>
</ul>
<p>接下來，我們來看，<code>call()</code>、<code>apply()</code>以及 <code>bind()</code> 如何與 <code>this</code> 運作。</p>
<h3 id="內建函式-call"><a href="#內建函式-call" class="headerlink" title="內建函式 call"></a>內建函式 call</h3><ul>
<li>單純將參數值傳入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`this為<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第二個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a)</span><br><span class="line">&#125;</span><br><span class="line">sum.call(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// &quot;this為2&quot;</span></span><br><span class="line"><span class="comment">// &quot;第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h3 id="內建函式-apply"><a href="#內建函式-apply" class="headerlink" title="內建函式 apply"></a>內建函式 apply</h3><ul>
<li>傳入的型態必須是陣列</li>
<li>功能上與 <code>call</code> 無異</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`陣列中第一個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`this為<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`陣列中第二個是<span class="subst">$&#123;b&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">sum.apply(<span class="number">1</span>, array)</span><br><span class="line"><span class="comment">// &quot;陣列中第一個是2&quot;</span></span><br><span class="line"><span class="comment">// &quot;this為1&quot;</span></span><br><span class="line"><span class="comment">// &quot;陣列中第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h3 id="內建函式-bind"><a href="#內建函式-bind" class="headerlink" title="內建函式 bind"></a>內建函式 bind</h3><ul>
<li><strong><code>bind()</code> 將建立一個新的函式</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例一</span></span><br><span class="line"><span class="comment">// bind會建立一個新的函式</span></span><br><span class="line"><span class="comment">// this會對應傳入的參數 newPerson</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jay&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newDisplay = display.bind(newPerson)</span><br><span class="line">display() <span class="comment">// Jay</span></span><br><span class="line">newDisplay() <span class="comment">// Vic</span></span><br><span class="line"><span class="comment">// 新的函式會執行 console.log(newPerson.name)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例二</span></span><br><span class="line"><span class="comment">// 若有多個值，bind的參數第一順位為 &#x27;this&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第一個是<span class="subst">$&#123;<span class="built_in">this</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第二個是<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> + a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> plusTwo = sum.bind(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plusTwo()</span><br><span class="line"><span class="comment">// &quot;第一個是2&quot;</span></span><br><span class="line"><span class="comment">// &quot;第二個是4&quot;</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="箭頭函式與-this"><a href="#箭頭函式與-this" class="headerlink" title="箭頭函式與 this"></a>箭頭函式與 this</h2><p>我們了解到箭頭函式沒有自己的 <code>this</code>，相對的也就沒有上述的那三種內建函式可供使用，也無法使用 <code>arguments</code>，但可以改用其餘參數來達成目的。箭頭函式與一般函式的運用，還是得看實際情況來做使用。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/@realdennis/javascript-%E8%81%8A%E8%81%8Acall-apply-bind%E7%9A%84%E5%B7%AE%E7%95%B0%E8%88%87%E7%9B%B8%E4%BC%BC%E4%B9%8B%E8%99%95-2f82a4b4dd66">realdennis - [JavaScript] 函數原型最實用的 3 個方法 — call、apply、bind</a></li>
<li><a href="https://medium.com/schaoss-blog/%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%A9%A6%E6%9C%80%E6%84%9B%E5%95%8F%E7%9A%84-apply-bind-call-708f57518776">Schaos - 一次搞懂前端面試最愛問的 apply、bind、call</a> </li>
<li><a href="https://ithelp.ithome.com.tw/articles/10195896">Henry Chang - JavaScript - call，apply，bind</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6變數宣告與全域環境</title>
    <url>/2020/10/29/javascript/ES6%E8%AE%8A%E6%95%B8%E5%AE%A3%E5%91%8A%E8%88%87%E5%85%A8%E5%9F%9F%E7%92%B0%E5%A2%83/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>一種被廣泛使用的程式語言，好上手也最容易踩雷，從 ES5進化到 ES6後增加了一些變數宣告方式與不少的語法糖，其歷史沿革已有很多前輩說明，為了方便之後描述，以下 JavaScript簡稱為 JS。</p>
<h2 id="JS-變數宣告"><a href="#JS-變數宣告" class="headerlink" title="JS 變數宣告"></a>JS 變數宣告</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>在 ES5時期，要宣告一個變數會使用 var作為開頭，但它有個缺點，就是它會建立在全域，在後續開發上會讓造成混淆，像是以下例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// window是 JS的最上層，也就是全域</span></span><br><span class="line"><span class="comment">// 它有很多 JS內建的事件與函式</span></span><br></pre></td></tr></table></figure>
<p>透過瀏覽器(開發者模式)來看，會發現在 window中找得到 a這個變數，這很可能讓後續寫下的變數或者函式抓到同樣的變數(註1)，進而造成不必要的錯誤。不過，它不是不能用，根據實際情況改變寫法才是我們要的。<br>順帶一提，若有安裝 ESLint這類的檢查工具，這個宣告方式還是會被建議改成 let。</p>
<p>註1 : 若函式裏頭未宣告且命名一個變數並賦予值，那麼此變數就會在全域環境中建立一個該變數的名稱(這個行為是 <strong>Hoisting</strong>，中文名為提升)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// c is not defined</span></span><br><span class="line"><span class="comment">// 執行 b函式時，全域環境中建立了名為 a的變數</span></span><br><span class="line"><span class="comment">// 而變數 c是在函式內宣告，因此在&quot;全域環境&quot;中找不到變數 c</span></span><br></pre></td></tr></table></figure>

<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ES6中，新增了 let與 const，這邊先介紹 let。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>只在某區塊(例如函式)中有作用</li>
<li>無法重複宣告同樣變數名稱</li>
<li>變數的值可改變</li>
</ul>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><p>為了解決 var所帶來的困擾，使用 let來做為變數宣告會是一個比較好的方式，它的作用範圍被限制在某個區塊中，就算不在函式中宣告，在 window中也找不到利用 let所宣告的變數。以下為範例 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>無法重複宣告</li>
<li>變數的值不可改變</li>
<li>若賦予的值為陣列或物件，可以改變其內部屬性</li>
</ul>
<p>使用 const宣告的變數為<strong>常數</strong>，無法改變其值，類似唯讀。</p>
<h2 id="全域環境"><a href="#全域環境" class="headerlink" title="全域環境"></a>全域環境</h2><p>上述的範例中會看到 window.a，這其實是物件的寫法，利用 var來宣告變數時，會在 window中新增一個物件屬性，為什麼會提到物件? 因為在說明 let時，自己不禁有個疑問，<code>let a</code> 有宣告，但在全域中卻找不到，那它去哪裡了?</p>
<h3 id="全域之複合環境"><a href="#全域之複合環境" class="headerlink" title="全域之複合環境"></a>全域之複合環境</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">這裡</a>似乎有相關的說明。目前自己的理解是，全域環境中是一個複合環境，包含 : </p>
<ul>
<li>物件環境 Object Environment</li>
<li>聲明環境 Declarative Environment<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以表格來看的話，類似像這樣 : <table>
<thead>
<tr>
<th>聲明環境</th>
<th>物件環境</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>10</td>
</tr>
<tr>
<td>b</td>
<td>funciton()</td>
</tr>
</tbody></table>
</li>
</ul>
<p>而 JS是物件導向，以物件來看的話，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 會在 Global內發現它們</span></span><br><span class="line">&#123;</span><br><span class="line">  a: <span class="number">10</span></span><br><span class="line">  b: f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="瀏覽器中的-Scope"><a href="#瀏覽器中的-Scope" class="headerlink" title="瀏覽器中的 Scope"></a>瀏覽器中的 Scope</h3><p>對於瀏覽器來說，當執行環境執行程式碼時，會在瀏覽器的 Scope產生 Global與 Script，而範例的執行環境就是全域環境，所以當變數沒有被告知用哪一種變數宣告，那麼就會根據 JS規則將此變數建立在 Global，若在全域環境下也用 var宣告，那麼就會是建立在 Global。<br>而使用 let與 const宣告時，它們會被建立在 Script，這就是為什麼無法在 window中找到的原因，因為它們的建立規則不是建立在 Global。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/pvt5r486/javascript-weird-day-2-%E5%85%A8%E5%9F%9F%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%85%A8%E5%9F%9F%E7%89%A9%E4%BB%B6-428bc0d61085">pvt5r486 - [JavaScript Weird] Day 2 — 全域執行環境與全域物件</a></li>
<li><a href="https://hsiangfeng.github.io/javascript/20200425/539985371/">Ray - 淺談 var 與 let 的差異以及有無宣告變數的差異</a></li>
<li><a href="https://medium.com/@realdennis/%E4%B8%80%E6%AC%A1%E8%AA%AA%E6%B8%85%E6%A5%9A-javascript-%E4%B8%AD%E5%AE%A3%E5%91%8A%E7%9A%84%E5%90%84%E7%A8%AE%E6%8F%90%E5%8D%87%E8%A1%8C%E7%82%BA-var-function-let-const-dd9175d063f0">realdennis - 一次說清楚 JavaScript 中宣告的各種提升行為（var、function、let/const）</a></li>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">Fun Lee - 关于 const 和 let 声明的变量不在 window 上</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6語法糖 - 解構賦值與其餘參數</title>
    <url>/2020/11/04/javascript/ES6%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E8%88%87%E5%85%B6%E9%A4%98%E5%8F%83%E6%95%B8/</url>
    <content><![CDATA[<h2 id="解構賦值"><a href="#解構賦值" class="headerlink" title="解構賦值"></a>解構賦值</h2><blockquote>
<p>解構賦值 (Destructuring assignment) 語法是一種 JavaScript 運算式，可以把陣列或物件中的資料解開擷取成為獨立變數。</p>
</blockquote>
<p>通常我們拿到的資料會是物件與陣列所組成，為了處理這些資料，需要使用迴圈、判斷等語法來取得相對應的資料，而陣列所包含的資料可能是複合性的或者物件屬性名稱不是我們要的，這時可以利用解構、展開運算子以及其餘參數混合使用達成我們的處理目的。若要透過函式處理更多事情，也能在函式的參數中使用。</p>
<p>在以下的段落會介紹 : </p>
<ul>
<li>陣列解構</li>
<li>物件解構</li>
<li>解構預設值</li>
<li>其餘參數與展開運算子</li>
</ul>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><h3 id="變數賦值"><a href="#變數賦值" class="headerlink" title="變數賦值"></a>變數賦值</h3><ul>
<li>宣告多個變數後，將它們用陣列的中括號包起來 <code>let [變數1, 變數2]</code></li>
<li>變數會<strong>對應</strong>陣列中絕對位置的陣列值，順序為由左至右</li>
<li>若缺少對應值，該變數則為 undefined</li>
</ul>
<h3 id="均有對應變數"><a href="#均有對應變數" class="headerlink" title="均有對應變數"></a>均有對應變數</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有變數在對應的位置賦值</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c ,d, e) </span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<h3 id="缺少變數"><a href="#缺少變數" class="headerlink" title="缺少變數"></a>缺少變數</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有限的變數在對應的位置賦值</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [x, , , y, z] = array</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z) </span><br><span class="line"><span class="comment">// 2 8 10</span></span><br></pre></td></tr></table></figure>
<h3 id="缺少對應值"><a href="#缺少對應值" class="headerlink" title="缺少對應值"></a>缺少對應值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數皆已宣告，但對應位置沒有賦予值</span></span><br><span class="line"><span class="comment">// 如同直接執行 console.log(d)</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, , , <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c ,d, e)</span><br><span class="line"><span class="comment">// 2 4 undefined undefined 10</span></span><br></pre></td></tr></table></figure>
<h3 id="其餘參數賦予新陣列"><a href="#其餘參數賦予新陣列" class="headerlink" title="其餘參數賦予新陣列"></a>其餘參數賦予新陣列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以利用其餘參數將剩下的元素形成一組新陣列</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// 2 4 [6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="變數交換"><a href="#變數交換" class="headerlink" title="變數交換"></a>變數交換</h3><ul>
<li>利用解構將變數賦值後，再將它們的值做交換</li>
<li>利用解構方式將變數值做交換時，上一行必須要有<strong>分號</strong>，否則會出錯</li>
<li>若使用套件 ESLint檢查的話，需要換個方式寫，將外層以大括號區隔<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [seatA, seatB] = [<span class="string">&#x27;Jay&#x27;</span>, <span class="string">&#x27;Vic&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(seatA, seatB); <span class="comment">// &quot;Jay&quot; &quot;Vic&quot;</span></span><br><span class="line"></span><br><span class="line">[seatA, seatB] = [seatB, seatA]</span><br><span class="line"><span class="comment">// 不用分號的寫法</span></span><br><span class="line"><span class="comment">// &#123;[seatA, seatB] = [seatB, seatA]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(seatA, seatB) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; &quot;Jay&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="字串解構"><a href="#字串解構" class="headerlink" title="字串解構"></a>字串解構</h3><ul>
<li>可以將字串每一個字元作為變數值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Vic&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [a, b ,c] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// &quot;V&quot; &quot;i&quot; &quot;c&quot; </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><ul>
<li>宣告多個變數後，將它們用物件的大括號包起來 <code>let &#123;變數1, 變數2&#125;</code></li>
<li>但它<strong>沒有順序</strong></li>
</ul>
<h3 id="一般物件解構"><a href="#一般物件解構" class="headerlink" title="一般物件解構"></a>一般物件解構</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Vic&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 宣告 name與 age為變數，只不過與物件內的屬性名稱相同</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name, age) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; 18</span></span><br></pre></td></tr></table></figure>

<h3 id="無宣告物件解構"><a href="#無宣告物件解構" class="headerlink" title="無宣告物件解構"></a>無宣告物件解構</h3><ul>
<li>未宣告的物件屬性值可以解構給已宣告變數<ul>
<li>如同上一個範例，變數的值為物件的屬性值</li>
<li>這裡不需將物件宣告</li>
</ul>
</li>
<li><strong>但變數名稱需與未宣告的物件屬性名稱相同</strong></li>
<li>已宣告的變數名稱可以再次給予新名稱</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:anonymous, <span class="attr">age</span>:anonymousAge&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;ccc&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125; </span><br><span class="line"><span class="built_in">console</span>.log(anonymous, anonymousAge) </span><br><span class="line"><span class="comment">// &quot;ccc&quot; 18</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解構預設值"><a href="#解構預設值" class="headerlink" title="解構預設值"></a>解構預設值</h2><ul>
<li>在解構陣列與物件時，若沒有對應的變數值，預設會是 undefined</li>
<li>可以在宣告時先給予一個預設值</li>
</ul>
<h3 id="陣列解構預設值"><a href="#陣列解構預設值" class="headerlink" title="陣列解構預設值"></a>陣列解構預設值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name=<span class="string">&#x27;匿名登入&#x27;</span>, age=<span class="string">&#x27;隱藏年齡&#x27;</span>] = [<span class="string">&#x27;Vic&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(name, age) </span><br><span class="line"><span class="comment">// &quot;Vic&quot; &quot;隱藏年齡&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="物件解構預設值"><a href="#物件解構預設值" class="headerlink" title="物件解構預設值"></a>物件解構預設值</h3><ul>
<li>給予預設值的同時，也可以賦予新的變數名稱，但只有物件可以</li>
<li><code>let &#123; 已宣告變數名:新的變數名 = 預設值 &#125;</code></li>
<li><code>let &#123;name:anonymous = &#39;匿名登入&#39;&#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:anonymous=<span class="string">&#x27;匿名登入&#x27;</span>, age=<span class="string">&#x27;隱藏年齡&#x27;</span>&#125; = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(anonymous, age)</span><br><span class="line"><span class="comment">// &quot;匿名登入&quot; &quot;隱藏年齡&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函式與預設值"><a href="#函式與預設值" class="headerlink" title="函式與預設值"></a>函式與預設值</h3><ul>
<li>可以將物件解構作為函式的參數並設定預設值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 單純參數預設值 */</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">name=<span class="string">&#x27;匿名登入&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">fnA() <span class="comment">// &quot;匿名登入&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物件解構預設值 */</span></span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">(<span class="params">&#123;name=<span class="string">&#x27;匿名登入&#x27;</span>, height=<span class="number">150</span>&#125;=&#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, height)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name:<span class="string">&#x27;Vic&#x27;</span>, </span><br><span class="line">  height:<span class="number">180</span></span><br><span class="line">&#125;</span><br><span class="line">fnB() <span class="comment">// &quot;匿名登入&quot; 150</span></span><br><span class="line">fnB(person) <span class="comment">// &quot;Vic&quot; 180</span></span><br></pre></td></tr></table></figure>

<h2 id="其餘參數與展開運算子"><a href="#其餘參數與展開運算子" class="headerlink" title="其餘參數與展開運算子"></a>其餘參數與展開運算子</h2><ul>
<li>寫法為三個點 <code>...</code></li>
<li>必須寫在變數名稱前面 <code>...變數名稱</code></li>
<li>兩者常會混淆，它們寫法相同，但行為不同</li>
</ul>
<h3 id="其餘參數"><a href="#其餘參數" class="headerlink" title="其餘參數"></a>其餘參數</h3><blockquote>
<p>其餘參數（rest parameter） 語法可以讓我們表示不確定數量的參數，並將其視為一個陣列。</p>
</blockquote>
<ul>
<li>可以將剩餘資料收集並組成一個新陣列</li>
<li>它為實體陣列，也就是說，它可以使用 <code>forEach()</code>、<code>length</code>等等…</li>
<li>它必需在最後一個位置才能使用</li>
</ul>
<h4 id="收集剩餘資料"><a href="#收集剩餘資料" class="headerlink" title="收集剩餘資料"></a>收集剩餘資料</h4><p>再看一次陣列解構中，有提到其餘參數的運用 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 陣列解構後賦予變數值</span></span><br><span class="line"><span class="comment">// 利用其餘參數將變數 c賦予一組新陣列</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = array</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) </span><br><span class="line"><span class="comment">// 2 4 [6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="展開運算子"><a href="#展開運算子" class="headerlink" title="展開運算子"></a>展開運算子</h3><blockquote>
<p>展開運算子(…) 允許可迭代的陣列或字串展開成０到多個參數(如果是function的話)或是０到多個元素(如果是array或字組的話)，或如果是物件的話則展開成０到多個key-value pair。</p>
</blockquote>
<ul>
<li>若對陣列展開，它會 return陣列中每一個值</li>
<li>若對物件展開，它會 return物件中每一個屬性名稱</li>
<li>若對字串展開，它為類陣列，會 return類陣列中每一個值</li>
</ul>
<h4 id="將陣列展開"><a href="#將陣列展開" class="headerlink" title="將陣列展開"></a>將陣列展開</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...array) </span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>

<h4 id="將字串展開"><a href="#將字串展開" class="headerlink" title="將字串展開"></a>將字串展開</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name =<span class="string">&#x27;Vic&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(...name)</span><br><span class="line"><span class="comment">// &quot;V&quot; &quot;i&quot; &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="綜合使用"><a href="#綜合使用" class="headerlink" title="綜合使用"></a>綜合使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b, ...c</span>) =&gt;</span> &#123; <span class="comment">// 將剩餘陣列值收集</span></span><br><span class="line">  <span class="built_in">console</span>.log(a+b)</span><br><span class="line">  <span class="comment">// reduce() 可以將陣列內所有值累加</span></span><br><span class="line">  <span class="built_in">console</span>.log(c.reduce(<span class="function">(<span class="params">d,e</span>) =&gt;</span> d+e))</span><br><span class="line">&#125;</span><br><span class="line">fn(...array) <span class="comment">// 將陣列展開</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<h2 id="解構賦值與其餘參數"><a href="#解構賦值與其餘參數" class="headerlink" title="解構賦值與其餘參數"></a>解構賦值與其餘參數</h2><p>參考別人的 JS寫法時，常會看到利用解構賦值與其餘參數的混和運用，但自己寫的時候卻常混淆它們的行為，三種不同的行為模式卻可以達成類似的目的，於是寫了這篇給自己看。要是能善加利用解構賦值、展開運算子以及其餘參數，對於函式的參數設計上會有很大的幫助。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN - 解構賦值</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters">MDN - 其餘參數</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN - 展開運算子</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/25/javascript-destructuring/">卡斯伯 - 鐵人賽：ES6 解構賦值</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/destructuring.html">從ES6開始的JavaScript學習生活 - 解構賦值</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/rest_spread.html">從ES6開始的JavaScript學習生活 - 展開運算符與其餘運算符</a></li>
<li><a href="https://medium.com/@realdennis/%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC-%E8%A8%AD%E8%A8%88%E5%87%BD%E6%95%B8%E6%99%82%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-javascript-1466f37d24f0">realdennis - 解構賦值 — 設計函數時的小技巧 JavaScript</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/12/15/javascript/JS%E6%A0%B8%E5%BF%83%E7%AF%87-Promise/</url>
    <content><![CDATA[<p>快速導覽 : </p>
<ul>
<li>Promise 例子<ul>
<li>AJAX</li>
<li>事件佇列</li>
</ul>
</li>
<li>Promise 狀態</li>
<li>Promise 建立</li>
<li>Promise 回傳資料與串接</li>
<li>Promise 常用資料回傳方法</li>
<li>透過 Promise改寫事件佇列</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是 ES6所新增的建構函式，常用來處理同步與非同步的問題，也增強了程式碼的可讀性。而 JS的執行順序是由上到下，若遇到事件則為進入事件佇列( Event queue  )中，就是非同步的問題，像是 : </p>
<ul>
<li>AJAX行為</li>
<li>監聽事件(click、change、…)</li>
<li><code>setTimeout( () =&gt; &#123; &#125; )</code></li>
</ul>
<h3 id="Promise-與-AJAX"><a href="#Promise-與-AJAX" class="headerlink" title="Promise 與 AJAX"></a>Promise 與 AJAX</h3><p>我們可以用原生 fetch語法或是直接使用第三方套件的 Axios來做 AJAX行為。</p>
<p>這邊提供一個資料測試網址(<a href="https://randomuser.me/api">點我</a>)，它可以取得一些 JSON格式的假資料。</p>
<h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>以下是 axios套件寫法 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 axios的 get方法取得資料</span></span><br><span class="line"><span class="comment">// 可以接收資料後， return 資料出來傳入下一個 then使用</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://randomuser.me/api&#x27;</span></span><br><span class="line"></span><br><span class="line">axios.get(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>利用 fetch原生語法來進行 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://randomuser.me/api&#x27;</span></span><br><span class="line"></span><br><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 必須從 response中 return response.json()給下一個 then</span></span><br><span class="line">    <span class="comment">// response 為被鎖定的名為的物件，ReadableStream，其中一個方法會回傳 JSON格式</span></span><br><span class="line">    <span class="comment">// 但是網址請求已被使用中，必須使用下一個 then再度請求後回傳</span></span><br><span class="line">    <span class="keyword">return</span> response.json(); </span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">jsonData</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(jsonData);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://randomuser.me/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    req.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(req.status = <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">// 成功時</span></span><br><span class="line">        resolve(req.response)</span><br><span class="line">        <span class="built_in">console</span>.log(req.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 失敗時</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    req.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">get(url).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>, res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Promise-與事件佇列"><a href="#Promise-與事件佇列" class="headerlink" title="Promise 與事件佇列"></a>Promise 與事件佇列</h3><p>通常我們會使用一些監聽事件等待使用者去觸發，或是用一個計時器，例如這樣 : </p>
<h4 id="一般事件佇列"><a href="#一般事件佇列" class="headerlink" title="一般事件佇列"></a>一般事件佇列</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout秒數就算設定為0，也會是最後出現</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;等待出現&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  alert(<span class="string">&#x27;使用者點擊&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, fn)</span><br></pre></td></tr></table></figure>

<p>但如果目標是讓每經過一秒顯示一次呢?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這樣會變成 1 秒後一起出現</span></span><br><span class="line"><span class="comment">// 而非每秒出現一次</span></span><br><span class="line"><span class="comment">// 當然也可以設計成 1000 &gt; 2000 &gt; 3000，但這不是我們要的</span></span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;等待出現&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;等待出現&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="透過-Promise來操作事件佇列"><a href="#透過-Promise來操作事件佇列" class="headerlink" title="透過 Promise來操作事件佇列"></a>透過 Promise來操作事件佇列</h4><p>像是上述的例子，可以透過 Promise來處理問題。</p>
<p>以下透過 Promise來操作事件佇列 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activeFn</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒後自動顯示`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">activeFn(<span class="number">1000</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 顯示第一次</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> activeFn(<span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 顯示第二次</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-狀態"><a href="#Promise-狀態" class="headerlink" title="Promise 狀態"></a>Promise 狀態</h2><div id="graphviz-0"></div>


<p>Promise會有三種狀態，分別是 : </p>
<table>
<thead>
<tr>
<th>狀態名稱</th>
<th>意義</th>
</tr>
</thead>
<tbody><tr>
<td>Pending</td>
<td>待機 / 未確認，以 AJAX行為來說，就是傳入網址等待取回資料</td>
</tr>
<tr>
<td>Fulfilled</td>
<td>已實現狀態，以 AJAX行為來說，就是取值成功時</td>
</tr>
<tr>
<td>Rejected</td>
<td>已否決狀態，以 AJAX行為來說，就是取值失敗時</td>
</tr>
</tbody></table>
<p>以上一次只會有一種狀態，並在實際使用時分別用不同的關鍵字取用。</p>
<ul>
<li>若進入 fulfilled<ul>
<li>使用 then接收上一個 return的值</li>
<li>使用函式將值作為參數傳入 <code>.then((參數名稱)=&gt;&#123;console.log(參數)&#125;)</code></li>
</ul>
</li>
<li>若進入 rejected<ul>
<li>使用 catch接收錯誤時會回報的值</li>
<li>使用函式將值作為參數傳入 <code>.catch((參數名稱)=&gt;&#123;console.log(參數)&#125;)</code></li>
</ul>
</li>
</ul>
<h2 id="Promise-建立"><a href="#Promise-建立" class="headerlink" title="Promise 建立"></a>Promise 建立</h2><ul>
<li>Promise是一個內建的函式 <code>(typeof Promise) // &quot;function&quot;</code></li>
<li>可以使用 new運算子轉為物件，但它需要傳入一個 function才能運作</li>
<li>根據使用者認為該<ul>
<li>情況正確使用 <code>resoleve()</code>回傳資料</li>
<li>若不正確是用 <code>reject()</code>回傳失敗訊息</li>
</ul>
</li>
<li>resolve與 reject可自定義參數名稱，不過為了避免混淆，還是習慣使用預設名稱</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseFn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 非同步行為</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功!&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;失敗!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promiseFn(<span class="number">1</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="Promise-回傳資料與串接"><a href="#Promise-回傳資料與串接" class="headerlink" title="Promise 回傳資料與串接"></a>Promise 回傳資料與串接</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseFn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 非同步行為</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功!&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;失敗!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promiseFn(<span class="number">1</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> promiseFn(<span class="number">2</span>) </span><br><span class="line">  <span class="comment">// 這個回傳的值會給下一個 then</span></span><br><span class="line">  <span class="comment">// 若值為假值 promiseFn(0)，會直接跳至 catch</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> promiseFn(<span class="number">4</span>)</span><br><span class="line">  <span class="comment">// 這個回傳的值會給下一個 then</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用 then傳入兩個函式 then(函式1, 函式2)，</span></span><br><span class="line"><span class="comment">// 前者接收 resolve狀態，後者 reject狀態</span></span><br><span class="line">promiseFn(<span class="number">1</span>).then(</span><br><span class="line">  (res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> promiseFn(<span class="number">0</span>) <span class="comment">// 會傳給下一個 then接收</span></span><br><span class="line">  &#125;, </span><br><span class="line">  (rej)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej, <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> promiseFn(<span class="number">1</span>) <span class="comment">// 會傳給下一個 then接收</span></span><br><span class="line">  &#125;).then(</span><br><span class="line">  (res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功!&#x27;</span>)</span><br><span class="line">  &#125;, </span><br><span class="line">  (rej)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;失敗!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Promise-常用資料回傳方法"><a href="#Promise-常用資料回傳方法" class="headerlink" title="Promise 常用資料回傳方法"></a>Promise 常用資料回傳方法</h2><ul>
<li>Promise.all <ul>
<li>等待全部執行完畢，並回傳所有結果</li>
<li>途中只要有狀態為 reject，會直接回傳 catch結果</li>
</ul>
</li>
<li>Promise.race<ul>
<li>只會回傳第一個執行完畢的函式並根據狀態回傳結果</li>
<li>只會回傳一組資料</li>
</ul>
</li>
</ul>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseFn</span>(<span class="params">num, time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 非同步行為</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功!&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;失敗!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promiseFn(<span class="number">1</span>, <span class="number">2000</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要途中有一個執行失敗的話，就會進入 reject狀態並回傳結果，不會再往下執行</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  promiseFn(<span class="number">1</span>, <span class="number">1000</span>),</span><br><span class="line">  promiseFn(<span class="number">0</span>, <span class="number">2000</span>),</span><br><span class="line">  promiseFn(<span class="number">1</span>, <span class="number">3000</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseFn</span>(<span class="params">num, time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 非同步行為</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功!&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;失敗!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promiseFn(<span class="number">1</span>, <span class="number">2000</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只取第一個先跑完的結果，再根據狀態回傳</span></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  promiseFn(<span class="number">1</span>, <span class="number">1000</span>),</span><br><span class="line">  promiseFn(<span class="number">1</span>, <span class="number">500</span>),</span><br><span class="line">  promiseFn(<span class="number">1</span>, <span class="number">3000</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="事件佇列與一般結果"><a href="#事件佇列與一般結果" class="headerlink" title="事件佇列與一般結果"></a>事件佇列與一般結果</h2><p>若想在事件佇列執行完畢後顯示其他結果，該怎麼做?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activeFn</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒後自動顯示`</span>)</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activeFn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;最後顯示&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">activeFn(<span class="number">3000</span>)</span><br><span class="line">activeFn2()</span><br><span class="line"><span class="comment">// &quot;最後顯示&quot; </span></span><br><span class="line"><span class="comment">// &#x27;1000毫秒後自動顯示&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-Promise修正結果"><a href="#利用-Promise修正結果" class="headerlink" title="利用 Promise修正結果"></a>利用 Promise修正結果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activeFn</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒後自動顯示`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activeFn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">`最後顯示`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 執行函式 &gt; 接收結果，return 函式執行的結果 &gt; 接收結果 </span></span><br><span class="line"></span><br><span class="line">activeFn(<span class="number">3000</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 顯示上一個函式執行的結果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="comment">// return 另一個函式執行的結果</span></span><br><span class="line">  <span class="keyword">return</span> activeFn2()</span><br><span class="line">  </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 顯示上一個函式執行的結果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;3000毫秒後自動顯示&quot;</span></span><br><span class="line"><span class="comment">// &quot;最後顯示&quot; </span></span><br></pre></td></tr></table></figure>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li>六角學院 - 核心篇</li>
<li><a href="https://www.oxxostudio.tw/articles/201706/javascript-promise-settimeout.html"> OXXO.STUDIO - JavaScript 同步延遲 ( Promise + setTimeout )</a><script src="https://unpkg.com/viz.js@2.1.2/viz.js"></script><script src="https://unpkg.com/viz.js@2.1.2/full.render.js"></script><textarea id="graphviz-0-code" style="display: none">digraph graphname {
  
  Promise [label="Promise" color=Block, fontcolor=Block, fontsize=24, ]      
  
  then [label=".then()" color=Blue, fontcolor=ForestGreen, fontsize=24, shape=box]  
 
  catch [label=".catch()" color=Blue, fontcolor=Red, fontsize=24, shape=box]
  
  Promise->then [label="  fulfilled     ", fontcolor=block, ] 

  Promise->catch [label="   rejected", fontcolor=block]
}</textarea><script>  var viz = new Viz();  var code = document.getElementById("graphviz-0-code").value;  viz.renderSVGElement(code)  .then(function(element) {    document.getElementById("graphviz-0").append(element)  });</script></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS核心篇-原型鏈</title>
    <url>/2020/12/08/javascript/JS%E6%A0%B8%E5%BF%83%E7%AF%87-%E5%8E%9F%E5%9E%8B%E9%8F%88/</url>
    <content><![CDATA[<p>當我們撰寫 JavaScript的程式碼時，為什麼會有那麼多的內建方法可以用? 例如一組陣列可以使用 <code>.length</code> 來得知陣列有多少位址資料，陣列內建的方式又是從何而來?</p>
<p>這裡紀錄一些關於原型的筆記 : </p>
<ul>
<li>原型物件<ul>
<li>原型屬性</li>
<li>原型繼承</li>
</ul>
</li>
<li>原型鏈</li>
<li>new Object( ) 自訂原型</li>
<li>Object.create( ) 將其他物件作為原型</li>
<li>多層繼承實作</li>
<li>物件屬性特徵</li>
</ul>
<h2 id="原型物件"><a href="#原型物件" class="headerlink" title="原型物件"></a>原型物件</h2><p>JavaScript是一個物件導向的語言，許多內建的方法都是透過繼承原型屬性來的，當我們打開以 JS撰寫的瀏覽器時，就建好基礎的原型方法。像是以下例子，原型的頂層為一個物件，其名稱為 <strong>Object</strong>。物件 <code>&#123;&#125;</code>、函式 <code>function</code>、陣列 <code>[]</code> ，都是繼承了這個原型物件內的屬性，再根據型別有自己的原生方法，例如陣列與函式的原生原型就不一樣。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>) </span><br><span class="line"><span class="comment">// 此為物件頂層，會發現一個名為 Object的函式</span></span><br><span class="line"><span class="comment">// 函式也是物件的一種，可以發現它擁有自己的物件屬性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>())</span><br><span class="line"><span class="comment">// 執行 Object() 這個函式會 return 一個名為 Object的物件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.__proto__) </span><br><span class="line"><span class="comment">// true，__proto__ 都是繼承了物件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype === <span class="built_in">Function</span>.prototype) </span><br><span class="line"><span class="comment">// false，原生原型不同</span></span><br></pre></td></tr></table></figure>
<h3 id="原型屬性"><a href="#原型屬性" class="headerlink" title="原型屬性"></a>原型屬性</h3><p>原型物件內建了很多原生屬性，我們可以自行增加共用的屬性，方式有兩個 : </p>
<ol>
<li><code>__proto__</code> ，繼承原型，建立在物件上<ul>
<li>每個物件都有此屬性</li>
<li>屬性特徵為可被列舉 </li>
<li><strong>原型鏈的關鍵</strong></li>
</ul>
</li>
<li><code>prototype</code> ，原生原型，建立在函式上<ul>
<li>函式才有此原生屬性</li>
<li>屬性特徵為不可被列舉</li>
</ul>
</li>
</ol>
<p>為什麼以下比對是 true?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype ) </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因為物件原型 <code>Object</code> 本身是一個函式，而</p>
<ul>
<li><code>Object</code> 這個函式繼承了 <code>function</code> 的原生原型</li>
<li><code>function</code> 又繼承了原型物件 <code>Object</code> 的原生原型</li>
</ul>
<p>所以它們指得是同樣的東西，可以使用 <code>console.dir(Object)</code> 驗證。(可以先往下看原型繼承，再回來想一下。)</p>
<hr>
<h3 id="原型繼承"><a href="#原型繼承" class="headerlink" title="原型繼承"></a>原型繼承</h3><p>以下比對可以了解繼承原型與原生原型。</p>
<p>首先，物件、函式與陣列本身為 <code>&quot;function&quot;</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>)   <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>)    <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>) <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-原生原型與繼承原型"><a href="#Object-原生原型與繼承原型" class="headerlink" title="Object 原生原型與繼承原型"></a>Object 原生原型與繼承原型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Object */</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.prototype === <span class="built_in">Object</span>.__proto__ ) </span><br><span class="line"><span class="comment">// false，前者是物件原生原型之物件，後者是繼承函式原型之函式</span></span><br><span class="line"><span class="comment">// Object，本身是為名為 Object的函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype ) </span><br><span class="line"><span class="comment">// true，前者是繼承函式原型又繼承物件原型之物件，後者是原生原型之物件</span></span><br></pre></td></tr></table></figure>

<h4 id="Function-原生原型與繼承原型"><a href="#Function-原生原型與繼承原型" class="headerlink" title="Function 原生原型與繼承原型"></a>Function 原生原型與繼承原型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Function  */</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Function</span>.prototype === <span class="built_in">Object</span>.__proto__ )  </span><br><span class="line"><span class="comment">// true，前者是函式原生原型之函式，後者是繼承函式原型之函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__ )  </span><br><span class="line"><span class="comment">// true，前者為函式原生原型之函式，後者為繼承函式原型之函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Function</span>.__proto__ === <span class="built_in">Object</span>.__proto__ )</span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( </span><br><span class="line">  <span class="built_in">Function</span>.__proto__.__proto__ === </span><br><span class="line">  <span class="built_in">Object</span>.__proto__.__proto__ </span><br><span class="line">)</span><br><span class="line"><span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h4 id="Array-原生原型與繼承原型"><a href="#Array-原生原型與繼承原型" class="headerlink" title="Array 原生原型與繼承原型"></a>Array 原生原型與繼承原型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Array */</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype === <span class="built_in">Object</span>.__proto__ ) </span><br><span class="line"><span class="comment">// false，前者為陣列原生原型之物件，後者為繼承函式原型之函式</span></span><br><span class="line"><span class="comment">// typeof Array.prototype 為 &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype === <span class="built_in">Array</span>.__proto__) </span><br><span class="line"><span class="comment">// false，前者為陣列原生原型之物件，後者為繼承函式原型之函式</span></span><br></pre></td></tr></table></figure>

<h4 id="Function-and-Array-原生原型與繼承原型"><a href="#Function-and-Array-原生原型與繼承原型" class="headerlink" title="Function and Array 原生原型與繼承原型"></a>Function and Array 原生原型與繼承原型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Function and Array*/</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Function</span>.prototype === <span class="built_in">Array</span>.prototype )</span><br><span class="line"><span class="comment">// false，原生原型不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Function</span>.__proto__ === <span class="built_in">Array</span>.__proto__ )</span><br><span class="line"><span class="comment">// true，均為繼承函式原型之函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( </span><br><span class="line">  <span class="built_in">Function</span>.__proto__.__proto__ === </span><br><span class="line">  <span class="built_in">Array</span>.__proto__.__proto__ </span><br><span class="line">)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在往後撰寫 JS程式碼時，就可以知道正在使用的陣列、函式以及物件是繼承誰的屬性。</p>
<hr>
<h2 id="原型鏈"><a href="#原型鏈" class="headerlink" title="原型鏈"></a>原型鏈</h2><ul>
<li>擁有物件的特性</li>
<li>會往上層搜尋</li>
<li>原型屬性可共用，不須額外撰寫<ul>
<li>可以新增屬性在原型中並賦予值，可以是陣列、函式、物件、純值等等…</li>
<li>其他物件可以利用點記號取用</li>
</ul>
</li>
</ul>
<p>例如下面的範例 :  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arrayB = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arrayA.name = <span class="string">&#x27;X陣列&#x27;</span></span><br><span class="line">arrayB.name = <span class="string">&#x27;Y陣列&#x27;</span></span><br><span class="line">arrayA.getLast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arrayA)</span><br><span class="line"><span class="built_in">console</span>.log(arrayA.getLast())</span><br><span class="line"><span class="built_in">console</span>.log(arrayB.getLast())</span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="comment">// &quot;X陣列&quot;</span></span><br><span class="line"><span class="comment">// arrayB.getLast is not a function </span></span><br></pre></td></tr></table></figure>
<p>上面的範例中 : </p>
<ul>
<li><code>arrayA</code> ，可以使用 getLast這個方法</li>
<li><code>arrayB</code> ，卻無法使用 getLast這個方法，因為只建立在 <code>arrayA</code> 這個物件下</li>
<li>若要讓 <code>arrayB</code> ，可以使用 getLast這個方法，就得再建立一次</li>
</ul>
<p>那如何讓方法共用呢? 我們可以利用<strong>原型鏈</strong>，新增一個共用方法在陣列這個實體物件上，像是這樣 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arrayB = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arrayA.name = <span class="string">&#x27;X陣列&#x27;</span></span><br><span class="line">arrayB.name = <span class="string">&#x27;Y陣列&#x27;</span></span><br><span class="line"><span class="comment">// 使用 __proto__ ，其繼承了陣列的原生原型</span></span><br><span class="line"><span class="comment">// 在這個原型屬性上建立一個新方法</span></span><br><span class="line">arrayA.__proto__.getLast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arrayA.getLast())</span><br><span class="line"><span class="built_in">console</span>.log(arrayB.getLast())</span><br><span class="line"><span class="comment">// &quot;X陣列&quot;</span></span><br><span class="line"><span class="comment">// &quot;Y陣列&quot;</span></span><br></pre></td></tr></table></figure>
<p>不過上述的例子無法使用 <code>prototype</code> ，因為這個實體陣列型別為 “object”，它沒有這個原型屬性，只有函式才有，而 <code>__proto__</code> 直接在繼承來的物件上新增共用方法。除非新增在原生原型 <code>Array.prototype.getLast()</code>，這樣所有陣列都能共用。</p>
<hr>
<h2 id="new-Object-自訂原型"><a href="#new-Object-自訂原型" class="headerlink" title="new Object( ) 自訂原型"></a>new Object( ) 自訂原型</h2><p>只需要在原型自訂方法，就不用浪費一堆記憶體空間(不用一直重開)。</p>
<p>舉個例子來說，打開某個編輯應用程式時，會問你是否套入範本，然後再問你基本資料要填入甚麼。<br>以下範例是一個構造函式，把它想成是一範本，利用這個範本去建立一個實體檔案，這個範本函式裏頭可以先寫上未來要成為物件時，所擁有的屬性，以建構式運算子建立時，就會成為該物件的屬性。<br>而範例中 :</p>
<ul>
<li>每個物件實體繼承了構造函式的屬性名稱，同時也繼承了物件的原生屬性</li>
<li>每個物件實體有自己的屬性值</li>
<li>不同物件時體會新開記憶體位置</li>
<li>每個物件實體之物件屬性為自己的原生原型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">motorCycle</span>(<span class="params">name, color, displacement</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">  <span class="built_in">this</span>.displacement = displacement</span><br><span class="line">  <span class="built_in">this</span>.congratulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Congratulations on the deal! Have a nice trip!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> motoA = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;Z900RS&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="number">948</span>)</span><br><span class="line"><span class="keyword">var</span> motoB = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;R1000&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(motoA.name)</span><br><span class="line"><span class="built_in">console</span>.log(motoB.color)</span><br><span class="line">motoB.congratulate()</span><br><span class="line"><span class="built_in">console</span>.log(motoA.congratulate === motoB.congratulate)</span><br><span class="line"><span class="comment">// &quot;Z900RS&quot;</span></span><br><span class="line"><span class="comment">// &quot;blue&quot;</span></span><br><span class="line"><span class="comment">// &quot;Congratulations on the deal! Have a nice trip!&quot;</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>雖然上述範例中，每個物件實體都能使用相同的方法，但它們屬於不同的記憶體位址，直接寫在構造函式中也不易閱讀，接著讓我們來改寫上述的範例 : </p>
<ul>
<li>將構造函式的方法移動到原生原型上，也就是物件原生原型</li>
<li>結果變成了 true，代表它們參考同樣的位址</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">motorCycle</span>(<span class="params">name, color, displacement</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">  <span class="built_in">this</span>.displacement = displacement</span><br><span class="line">&#125;</span><br><span class="line">motorCycle.prototype.congratulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Congratulations on the deal! Have a nice trip!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> motoA = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;Z900RS&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="number">948</span>)</span><br><span class="line"><span class="keyword">var</span> motoB = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;R1000&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(motoA.congratulate === motoB.congratulate)</span><br><span class="line"><span class="built_in">console</span>.log(motoA.__proto__ === motorCycle.prototype ) </span><br><span class="line"><span class="built_in">console</span>.log(motorCycle.__proto__ === <span class="built_in">Function</span>.prototype ) </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true，motoA繼承了 motorCycle的原生原型，但沒有繼承函式的原生原型</span></span><br><span class="line"><span class="comment">// true，motorCycle繼承了 Function的原生原型</span></span><br></pre></td></tr></table></figure>
<h3 id="建構式物件繼承了甚麼"><a href="#建構式物件繼承了甚麼" class="headerlink" title="建構式物件繼承了甚麼"></a>建構式物件繼承了甚麼</h3><p>不知道看到這裡會不會有個疑問，<code>motoA</code> 這個物件實體怎麼沒有繼承函式的原生原型，讓我們用 <code>console.log(motoA.__proto__)</code> 檢查它繼承了甚麼?</p>
<ul>
<li><code>congratulate</code><ul>
<li>繼承 motorCycle的原生原型之自訂方法</li>
</ul>
</li>
<li><code>constructor</code><ul>
<li>繼承 motorCycle這個函式</li>
<li>可以利用它來<strong>辨認是從哪一個建構函式繼承的</strong></li>
</ul>
</li>
<li><code>__proto__</code><ul>
<li>繼承物件的原生原型</li>
<li>建構式物件型別為 “object”</li>
</ul>
</li>
</ul>
<h3 id="如何得知該方法為物件所有還是繼承的"><a href="#如何得知該方法為物件所有還是繼承的" class="headerlink" title="如何得知該方法為物件所有還是繼承的"></a>如何得知該方法為物件所有還是繼承的</h3><p>可以利用 <code>hasOwnProperty</code> 來檢查。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">array.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log( array.hasOwnProperty(<span class="string">&#x27;forEach&#x27;</span>)) </span><br><span class="line"><span class="built_in">console</span>.log( array.hasOwnProperty(<span class="string">&#x27;length&#x27;</span>)) </span><br><span class="line"><span class="built_in">console</span>.log( array.__proto__.hasOwnProperty(<span class="string">&#x27;forEach&#x27;</span>)) </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-create-將其他物件作為原型"><a href="#Object-create-將其他物件作為原型" class="headerlink" title="Object.create( ) 將其他物件作為原型"></a>Object.create( ) 將其他物件作為原型</h2><p>除了使用構造函式轉為建構物件來自訂原生原型屬性，也可以將另一個物件直接作為建構物件使用。</p>
<ol>
<li>自訂構造函式 &gt; 建構物件 &gt; 實體物件</li>
<li>將另一個物件屬性作為建構物件 &gt; 實體物件<ul>
<li>新的實體物件透過 <code>Object.create(另一物件)</code> 將其作為原生原型屬性(包含屬性值)</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">motorCycle</span>(<span class="params">name, color, displacement</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">  <span class="built_in">this</span>.displacement = displacement</span><br><span class="line">&#125;</span><br><span class="line">motorCycle.prototype.congratulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Congratulations on the deal! Have a nice trip!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> motoA = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;Z900RS&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="number">948</span>)</span><br><span class="line"><span class="keyword">var</span> motoB = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;R1000&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> motoC = <span class="built_in">Object</span>.create(motoA)</span><br><span class="line">motoC.color = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(motoC)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(motoC.prototype === motoA.prototype) </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 原生原型看起來相同，但要注意，建構物件型別為 &quot;object&quot;</span></span><br><span class="line"><span class="comment">// 也就是說，它們沒有 prototype這個屬性，是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(motoC.__proto__ === motoA) </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 繼承另一個物件屬性作為原型</span></span><br></pre></td></tr></table></figure>
<p>但是上面的範例這樣做會有點問題，繼承來的原生原型是一個物件，若不變更屬性值，基本上它們的 console.log() 內容一樣，但它是利用原型鏈向上層找，本身沒有自己的屬性，像這樣 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 這是 motoC */</span></span><br><span class="line"><span class="built_in">console</span>.log(motoC)</span><br><span class="line"><span class="comment">// 在開發者模式下的結果</span></span><br><span class="line"><span class="comment">// motorCycle &#123;</span></span><br><span class="line"><span class="comment">//   __proto__ : motorCycle</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 這是 motoA */</span></span><br><span class="line"><span class="built_in">console</span>.log(motoA)</span><br><span class="line"><span class="comment">// motorCycle &#123;</span></span><br><span class="line"><span class="comment">//   name: &#x27;Z900RS&#x27;</span></span><br><span class="line"><span class="comment">//   color: &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">//   displacement: 948</span></span><br><span class="line"><span class="comment">//   __proto__ : Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>不過，還是可以利用 <code>Object.create()</code> 來快速複製屬性，例如繼承多個物件屬性時會用到它。</p>
<h2 id="多層繼承實作"><a href="#多層繼承實作" class="headerlink" title="多層繼承實作"></a>多層繼承實作</h2><p>JS無法同時繼承多個物件，但是可以使用多層繼承的方式，實作中我們會用到 : </p>
<ul>
<li><code>Object.creat()</code></li>
<li><code>new Object()</code></li>
<li><code>prototype</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object &gt; Transportation &gt; 汽車、摩托車、飛機 &gt; 保時捷911、Z900RS、A320</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交通工具 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Transportation</span>(<span class="params">tool</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.toolName = tool || <span class="string">&#x27;交通工具&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在頂層交通工具函式原型上新增共用方法</span></span><br><span class="line">Transportation.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.toolName + <span class="string">&#x27;向前移動&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Transportation.prototype.congratulate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Congratulations on the deal! Have a nice trip!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交通工具類別*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">motorCycle</span>(<span class="params">name, color, displacement</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 執行 Transportation.call() 並填入工具名稱，完成該工具類別屬性</span></span><br><span class="line">  <span class="comment">// 未加入任何原型</span></span><br><span class="line">  Transportation.call(<span class="built_in">this</span>, <span class="string">&#x27;摩托車&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">  <span class="built_in">this</span>.displacement = displacement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 將交通工具類別的原型更改為頂層交通工具</span></span><br><span class="line">motorCycle.prototype = <span class="built_in">Object</span>.create(Transportation.prototype)</span><br><span class="line"><span class="comment">// motorCycle.prototype = Transportation.prototype</span></span><br><span class="line"><span class="comment">// 這樣也是可以運作，但是這樣變成傳參考，修改 motorCycle.prototype時，</span></span><br><span class="line"><span class="comment">// 也會一併修改 Transportation.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將交通工具的類別的建構函式改回自己，否則為頂層交通工具的建構函式</span></span><br><span class="line"><span class="comment">// 有助於辨別從哪個函式轉來</span></span><br><span class="line">motorCycle.prototype.constructor = motorCycle</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將交通工具的類別，新增一個只有該類別才能用的函式</span></span><br><span class="line">motorCycle.prototype.wheelie = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;翹孤輪~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 雖然它的繼承原型還是 Transportation，</span></span><br><span class="line"><span class="comment">// 但是同一層的建構函式已修改回原本交通工具類別，還是可以辨認</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> motoA = <span class="keyword">new</span> motorCycle(<span class="string">&#x27;Z900RS&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="number">948</span>)</span><br><span class="line">motoA.move() <span class="comment">// &quot;摩托車向前移動&quot;</span></span><br><span class="line">motoA.wheelie() <span class="comment">// &quot;翹孤輪~&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="物件屬性特徵"><a href="#物件屬性特徵" class="headerlink" title="物件屬性特徵"></a>物件屬性特徵</h2><p>當我們使用原型來新增方法時，有沒有發現到有個東西會用到，但實際上看不到它?</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>當我們新增一個方法在函式原型上，為什麼使用 console.log()時，卻找不到 <code>prototype</code> 呢? 讓我們使用 <code>Object.getOwnPropertyDescriptor</code> 這個方式來檢查該 prototype 這個物件屬性，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造一個構造函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proto</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接著，在原型上新增一個方法</span></span><br><span class="line">proto.prototype.fnA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;函式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(proto, <span class="string">&#x27;prototype&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   value: &#123;</span></span><br><span class="line"><span class="comment">//     fnA: funciton()&#123;</span></span><br><span class="line"><span class="comment">//       console.log(&#x27;函式&#x27;)</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     constructor: ƒ proto(name),</span></span><br><span class="line"><span class="comment">//     __proto__: Object&#123;...&#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   writable: true, // 可寫入</span></span><br><span class="line"><span class="comment">//   configurable: false, // 不可被刪除</span></span><br><span class="line"><span class="comment">//   enumerable: false, // 不可被列舉</span></span><br><span class="line"><span class="comment">//   __proto__: Object&#123;...&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>我們可以發現，<code>prototype</code> 這個屬性設定的其中兩個為 false</p>
<ul>
<li>configurable 可否被刪除</li>
<li>enumerable 可否被列舉</li>
</ul>
<p>很多教學建議新增原型方法時，盡量設定在這個屬性上，但實際上又看不到它，而上述就是為什麼看不到 <code>prototype</code> 這個屬性的原因。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li>六角學院 - JS核心篇</li>
<li><a href="https://blog.techbridge.cc/2017/04/22/javascript-prototype/">Huli- 該來理解 JavaScript 的原型鍊了</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN - 繼承與原型鏈</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS核心篇-物件屬性特徵</title>
    <url>/2020/12/10/javascript/JS%E6%A0%B8%E5%BF%83%E7%AF%87-%E7%89%A9%E4%BB%B6%E5%B1%AC%E6%80%A7%E7%89%B9%E5%BE%B5/</url>
    <content><![CDATA[<p>本文快速導覽 : </p>
<ul>
<li>物件屬性設定<ul>
<li>單一屬性設定 <code>Object.definedProperty(物件, 屬性)</code> </li>
<li>多個屬性設定 <code>Object.defineProperties(物件, &#123; 屬性:&#123;&#125;, 屬性2:&#123;&#125;&#125;)</code> </li>
</ul>
</li>
<li>物件設定方法<ul>
<li>防止物件屬性擴充 <code>Object.preventExtensions(物件)</code> </li>
<li>封裝物件 <code>Object.seal</code></li>
<li>凍結物件 <code>Object.freeze</code></li>
</ul>
</li>
<li>檢查物件設定<ul>
<li>回傳物件屬性設定 <code>Object.getOwnPropertyDescriptor(物件, 屬性)</code> </li>
<li>回傳多個物件屬性設定 <code>Object.getOwnPropertyDescriptors(物件, 屬性1, 屬性2)</code></li>
<li>物件屬性可否被擴充 <code>Object.isExtensible(物件)</code> (true or fasle)</li>
<li>物件是否被封裝 <code>Object.isSealed(物件)</code></li>
<li>物件是否被凍結 <code>Object.isFrozen(物件)</code></li>
<li>列舉物件屬性 <code>Object.keys(物件)</code><ul>
<li>只回傳可被列舉的屬性名稱</li>
<li>與 <code>for in</code> 一致</li>
<li>回傳陣列 <code>[屬性1, 屬性2, ...]</code></li>
</ul>
</li>
<li>列舉物件屬性 <code>Object.getOwnPropertyNames(物件)</code><ul>
<li>不管是否無法被列舉，都會顯示其屬性名稱</li>
<li>回傳陣列 <code>[屬性1, 屬性2, ...]</code></li>
</ul>
</li>
</ul>
</li>
<li>賦值運算不使用額外函式<ul>
<li>Getter 與 Setter  </li>
<li>錯誤設定</li>
</ul>
</li>
</ul>
<p>(快速導覽包含一些本文未使用的方法，以方便日後搜尋)</p>
<h2 id="物件屬性設定"><a href="#物件屬性設定" class="headerlink" title="物件屬性設定"></a>物件屬性設定</h2><p>在原型鏈中，我們會用 <code>某函式.prototype.要新增的屬性名稱</code> 在原生原型上新增共用的方法或值，但新增後使用 <code>console.log()</code> 卻找不到它，這是怎麼一回事? 原因在於它的屬性被 <code>Object.definedProperty</code> 設定了。</p>
<h3 id="單一屬性設定-Object-definedProperty"><a href="#單一屬性設定-Object-definedProperty" class="headerlink" title="單一屬性設定 Object.definedProperty"></a>單一屬性設定 Object.definedProperty</h3><table>
<thead>
<tr>
<th>可設定特徵名稱</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>值</td>
</tr>
<tr>
<td>writable</td>
<td>可否寫入</td>
</tr>
<tr>
<td>configurable</td>
<td>可否被刪除</td>
</tr>
<tr>
<td>enumerable</td>
<td>可否被列舉</td>
</tr>
</tbody></table>
<p>要注意的是，<code>Object.definedProperty</code> 只能針對當下的物件屬性作設定，若物件內屬性值也為物件，還是可以被寫入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 物件屬性設定 */</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 不可寫入</span></span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可被刪除</span></span><br><span class="line">  enumerable: <span class="literal">false</span> <span class="comment">// 不可被列舉</span></span><br><span class="line">&#125;)</span><br><span class="line">person.a = <span class="number">100</span> </span><br><span class="line"><span class="keyword">delete</span> person.a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用 for in 的方式看每個屬性名稱，</span></span><br><span class="line"><span class="comment">// 會發現 person.a 還在</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.a) </span><br><span class="line"><span class="comment">// 10，不可再寫入，不能被刪除，也不能被列舉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若物件內屬性值也為物件，還是可以被寫入 */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;d&#x27;</span>, &#123;</span><br><span class="line">  value: &#123;&#125;,</span><br><span class="line">  writable: <span class="literal">true</span>, </span><br><span class="line">  configurable: <span class="literal">true</span>, </span><br><span class="line">  enumerable: <span class="literal">true</span> </span><br><span class="line">&#125;)</span><br><span class="line">person.d.a = <span class="number">1000</span></span><br><span class="line"><span class="built_in">console</span>.log(person.d.a) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="多個屬性特徵設定-Object-defineProperties"><a href="#多個屬性特徵設定-Object-defineProperties" class="headerlink" title="多個屬性特徵設定 Object.defineProperties"></a>多個屬性特徵設定 Object.defineProperties</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一次修改多屬性設定 */</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    value: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.d = []</span><br><span class="line"><span class="built_in">console</span>.log(person.b) <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(person.d) <span class="comment">// &#123; a:1000 &#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="物件設定方法"><a href="#物件設定方法" class="headerlink" title="物件設定方法"></a>物件設定方法</h2><p>除了可以設定物件內屬性，也可以針對物件本身去設定，像是 : </p>
<ul>
<li><code>Object.preventExtensions</code><ul>
<li>防止擴充 / 無法新增屬性，但無法針對巢狀屬性禁止</li>
</ul>
</li>
<li><code>Object.seal</code><ul>
<li>封裝</li>
</ul>
</li>
<li><code>Object.Freeze</code><ul>
<li>凍結</li>
</ul>
</li>
</ul>
<h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions"></a>Object.preventExtensions</h3><ul>
<li>防止該物件屬性被擴充，但它無法對巢狀物件屬性禁止</li>
<li>屬性可以被刪除<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  a:<span class="number">1</span>, </span><br><span class="line">  b:<span class="number">2</span>, </span><br><span class="line">  c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person)</span><br><span class="line"><span class="keyword">delete</span> person.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回傳布林值，是否可被擴充</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;是否可以被擴充:&#x27;</span>+ <span class="built_in">Object</span>.isExtensible(person))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查物件屬性設定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   configurable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   value: 1,</span></span><br><span class="line"><span class="comment">//   writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   a: 1,</span></span><br><span class="line"><span class="comment">//   b: 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h3><ul>
<li>不能調整屬性特徵</li>
<li>可以調整目前屬性值</li>
<li>物件屬性會被加上 preventExtensions</li>
<li>無法新增刪除屬性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  a:<span class="number">1</span>, </span><br><span class="line">  b:<span class="number">2</span>, </span><br><span class="line">  c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.seal(person)</span><br><span class="line">person.a = <span class="number">1000</span></span><br><span class="line">person.d = <span class="number">10</span></span><br><span class="line"><span class="keyword">delete</span> person.b</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">person.b = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回傳布林值，是否被封裝</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;是否被封裝:&#x27;</span>+ <span class="built_in">Object</span>.isSealed(person))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查物件屬性設定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   configurable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   value: 1000,</span></span><br><span class="line"><span class="comment">//   writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   a: 1000,</span></span><br><span class="line"><span class="comment">//   b: 2000,</span></span><br><span class="line"><span class="comment">//   c: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p>物件使用 <code>Object.Freeze</code> 凍結後，就無法對它修改屬性設定，否則會報錯。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  a:<span class="number">1</span>, </span><br><span class="line">  b:<span class="number">2</span>, </span><br><span class="line">  c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.Freeze(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回傳布林值，是否被凍結</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;是否被凍結:&#x27;</span>+ <span class="built_in">Object</span>.isFrozen(person))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查物件屬性設定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   configurable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   value: 1,</span></span><br><span class="line"><span class="comment">//   writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="賦值運算不使用額外函式"><a href="#賦值運算不使用額外函式" class="headerlink" title="賦值運算不使用額外函式"></a>賦值運算不使用額外函式</h2><p>物件屬性還有兩個特徵可以設定，分別是 Getter 與 Setter，以下就來看看它們怎麼運作。</p>
<h3 id="Getter-與-Setter"><a href="#Getter-與-Setter" class="headerlink" title="Getter 與 Setter"></a>Getter 與 Setter</h3><ul>
<li>Getter，取值<ul>
<li>使用 console.log()檢查時，狀態為 <code>...</code>，當點開時才會正確取值</li>
</ul>
</li>
<li>Setter，存值<ul>
<li>必須要有傳入參數，否則報錯</li>
<li>console.log()、return 不會有任何作用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="keyword">get</span> <span class="title">getData</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">addData</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">a.addData = <span class="string">&quot;99&quot;</span></span><br><span class="line">a.addData = <span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="使用-Object-defineProperty，設定-Getter、Setter"><a href="#使用-Object-defineProperty，設定-Getter、Setter" class="headerlink" title="使用 Object.defineProperty，設定 Getter、Setter"></a>使用 Object.defineProperty，設定 Getter、Setter</h3><p>若有一個已知的物件其屬性未設定 Getter、Setter，可以使用 defineProperty來設定。透過這個方式設定時，Getter、Setter的預設為不可列舉也不可被刪除。以下範例使用了 : </p>
<ul>
<li>多個屬性特徵設定</li>
<li>Getter 與 Setter<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收入來源有股票與工作</span></span><br><span class="line"><span class="comment">// 將它們分別設定 Getter 與 Setter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sourceofIncome = &#123;</span><br><span class="line">  money: <span class="number">0</span>,</span><br><span class="line">  stock: <span class="literal">null</span>,</span><br><span class="line">  work: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(sourceofIncome, &#123;</span><br><span class="line">  money: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  stock: &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">money</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.__stock__ = money</span><br><span class="line">      <span class="built_in">this</span>.money += money</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`股票賺了: <span class="subst">$&#123;<span class="built_in">this</span>.__stock__&#125;</span>，現在有: <span class="subst">$&#123;<span class="built_in">this</span>.money&#125;</span>`</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  work: &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">money</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.__work__ = money</span><br><span class="line">      <span class="built_in">this</span>.money += money</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`股票賺了: <span class="subst">$&#123;<span class="built_in">this</span>.__work__&#125;</span>，現在有: <span class="subst">$&#123;<span class="built_in">this</span>.money&#125;</span>`</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">sourceofIncome.stock = <span class="number">20000</span></span><br><span class="line">sourceofIncome.work = <span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若分段顯示就會是分段的，現在金額顯示為累計過的</span></span><br><span class="line"><span class="built_in">console</span>.log(sourceofIncome.stock)</span><br><span class="line"><span class="built_in">console</span>.log(sourceofIncome.work)</span><br><span class="line"><span class="built_in">console</span>.log(sourceofIncome.money)</span><br></pre></td></tr></table></figure></li>
<li>若要設定屬性值，可以針對屬性再多一個屬性，像是 <code>this.__work__</code>，否則指向自己，會變成無限循環。</li>
<li>取用屬性時，可以同時做很多事，不用再額外寫函式傳參數進去。</li>
</ul>
<h3 id="錯誤設定"><a href="#錯誤設定" class="headerlink" title="錯誤設定"></a>錯誤設定</h3><p>設定過程中可能會遇到以下問題 : </p>
<ol>
<li><code>Maximum call stack size exceeded</code><ul>
<li>Getter 與 Setter 不能指向自己，否則會造成無限循環。</li>
</ul>
</li>
<li><code>Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;</code><ul>
<li>因為屬性特徵不相容<ul>
<li>資料描述器 ( data descriptor ) : value、writable與其他</li>
<li>存取器描述器 ( accessor descriptor ) : get 與 set</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li>六角學院 - JS核心篇</li>
<li><a href="https://andyyou.github.io/2017/10/28/javascript-object-property/?fbclid=IwAR1Uh6dwUEPz-fl7iJQaFM9dj7elVzCE0QjTdpdSYLq6UY-v4LFAH1Q_ovU">andyyou - 深入 ECMAScript 5 物件屬性</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10197827?sc=pt">Henry Chang - JavaScript - 屬性描述器 (2)</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>提升</title>
    <url>/2020/12/11/javascript/%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>分別呼叫這些例子，會產生甚麼結果?</p>
<p>E.g. 1. : console.log 結果會是?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>E.g. 2 : console.log 結果會是?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>E.g. 3 : fnA() 是否執行? 又會產生甚麼?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>E.g. 4 : console.log 結果會是?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">1</span></span><br><span class="line"><span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="變數提升"><a href="#變數提升" class="headerlink" title="變數提升"></a>變數提升</h2><p>當我們宣告變數時，JS就會先開一個記憶體位置來存放，而它的預設值為 ‘undefined’，最後賦予我們給這個變數的值。<br>而 JS的執行順序為由上至下且依序執行，所以範例1與範例2的樣子就會是 :<br>E.g. 1 : console.log 結果會是 a is not defined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) </span><br></pre></td></tr></table></figure>
<p>E.g. 2 : console.log 結果會是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>實際上它的執行順序是這樣 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="函式提升"><a href="#函式提升" class="headerlink" title="函式提升"></a>函式提升</h2><p>在 JS中，它會依據函式定義的位置順序，依序將函式提升到最上方，但在函式內的不會移動到外層。<br>E.g. 3 : fnA() 會執行並 return 1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn()</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>實際上它的執行順序是這樣 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="number">1</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>而在函式內的函式不會提升到外層，但是可以呼叫外層的函式 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fnB()</span><br><span class="line"> fnC()</span><br><span class="line"> <span class="keyword">var</span> fnB = <span class="function">() =&gt;</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fnC = <span class="function">() =&gt;</span> <span class="number">3</span></span><br><span class="line">fnA()</span><br></pre></td></tr></table></figure>
<p>不過，如果將匿名函式賦予到一個變數上，就會根據變數的規則走。</p>
<hr>
<h2 id="變數與函式提升的優先程度"><a href="#變數與函式提升的優先程度" class="headerlink" title="變數與函式提升的優先程度"></a>變數與函式提升的優先程度</h2><p>在 JS中，會將優先將函式提升到最上方，接著再宣告變數，而函式的參數傳遞限於函式內並且是最優先，重新宣告它無任何意義。<br>E.g. 4 : console.log 結果會是 function fn( ){}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line"><span class="comment">// 第一次 console.log(fn) 為 function fn()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line"><span class="comment">// 第二次 console.log(fn) 為 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  fnB(<span class="number">10</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">fnA(<span class="number">1</span>) </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 若使用 let 宣告 a會報錯，因為 a為參數</span></span><br><span class="line"><span class="comment">// Identifier &#x27;a&#x27; has already been declared </span></span><br><span class="line"><span class="comment">// fnB() 的參數其實跟 fnA的參數 a無關，只看 fnB()真正執行時傳了甚麼值進去</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Hosting-做了甚麼事"><a href="#Hosting-做了甚麼事" class="headerlink" title="Hosting 做了甚麼事"></a>Hosting 做了甚麼事</h2><p>我們打開編輯器撰寫 JS時，其實是在一個全域環境底下開始寫程式，它同時是全域也是執行環境，當我們宣告一個 function時，也會同時建立 : </p>
<ul>
<li>獨立的執行環境 ( Execution Contexts )</li>
<li>獨立的變數物件 ( Variable Object )</li>
</ul>
<p>以下的例子有不同情況 : </p>
<ol>
<li><p>多餘的變數，其預設為 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立執行環境 Execution Contexts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">fnA(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 10 undefined undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立變數物件 VO </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a:10</span></span><br><span class="line"><span class="comment">//   b:undefined</span></span><br><span class="line"><span class="comment">//   c:undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函式內建立函式，函式若與參數同名會被覆蓋</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 執行環境 Execution Contexts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">fnA(fnB)</span><br><span class="line"><span class="comment">// function a()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 參數 a 被函式覆蓋掉</span></span><br><span class="line"><span class="comment">// VO variable object</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a: function a()&#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>總合以上情況並再次宣告參數然後賦予值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">  <span class="comment">// 10 function b()&#123;&#125; undefined</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">5</span></span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">fnA(<span class="number">10</span>, fnB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 為什麼 c不是 5? 因為它宣告被忽略且呼叫時未被設定成 5</span></span><br><span class="line"><span class="comment">// 在第二次呼叫 c 時，已被設定成 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VO variable object</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a: 10,</span></span><br><span class="line"><span class="comment">//   b: function b()&#123;&#125;,</span></span><br><span class="line"><span class="comment">//   c: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>透過以上例子可以發現，當有執行環境後，就會有變數物件，而它在函式中會做以下三件事 : </p>
<ul>
<li>若參數值為函式且參數名稱同名則覆蓋成函式</li>
<li>若函式內宣告且與參數名稱同名則忽略</li>
<li>參數名稱若有設定，預設值為 undefined</li>
</ul>
<p>回到全域環境後，就更加單純，使用 var宣告的函式與變數會被覆蓋，若該變數未賦予值時，預設值為 undefined。</p>
<p>再回想一下，當我們寫好 JS程式碼後，透過瀏覽器執行，其實是開始創建接著執行，在創建(包含編譯)的過程中，<strong>Hosting 就是在建立變數物件的過程。</strong></p>
<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 撰寫 &gt; 創建(包含建立變數物件) &gt; 執行</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>


<h2 id="Temporal-Dead-Zone"><a href="#Temporal-Dead-Zone" class="headerlink" title="Temporal Dead Zone"></a>Temporal Dead Zone</h2><p>目前的範例都是使用 var 來宣告，ES6開始就推薦以 let或 const 來宣告變數，那麼 let 與 const 所宣告的變數與函式也具有提升特性嗎?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization </span></span><br></pre></td></tr></table></figure>
<p>上面錯誤的意義是，未初始化變數 a前，無法存取它的值，為什麼會這樣?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 執行環境</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line"><span class="comment">// VO，在變數物件中還是有建立名稱，</span></span><br><span class="line"><span class="comment">// 但按照依序執行的規則變成了未賦予值</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  a: ?</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>為了解釋這個空窗期，於是就有了這個名詞 Temporal Dead Zone。拋出錯誤的目的還是希望開發者的撰寫習慣能改變吧?! </p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">Huli - 我知道你懂 hoisting，可是你了解到多深？</a></li>
<li><a href="https://shawnlin0201.github.io/JavaScript/JavaScript-Variable-Object-and-Activation-Object/">ShawnL - JavaScript 深入淺出 Variable Object &amp; Activation Object</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10219518">江江好 - Day22【ES6 小筆記】變數提升（Hoisting）與暫時死區（TDZ）</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>物件</title>
    <url>/2020/11/25/javascript/%E7%89%A9%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="物件結構"><a href="#物件結構" class="headerlink" title="物件結構"></a>物件結構</h2><p>建立物件有兩個方式 : </p>
<ul>
<li>物件實字</li>
<li>建構式物件</li>
</ul>
<p>物件實字比起建構式更容易閱讀，也不需要額外繼承 <code>Object()</code> ，多數人推薦以此方式建立物件，而建構式物件則是學習建構式或者原型時再來使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objA = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">objB.a = <span class="number">1</span></span><br><span class="line">objB.b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="物件操作-取值、新增、刪除"><a href="#物件操作-取值、新增、刪除" class="headerlink" title="物件操作(取值、新增、刪除)"></a>物件操作(取值、新增、刪除)</h2><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>可以使用兩種方式來取得物件的屬性值 :　</p>
<ol>
<li>使用<strong>點記號</strong>來取值 <code>.</code><ul>
<li>必須使用字串去取得屬性名稱</li>
<li>無法使用 <code>.數值</code> 取得屬性值，例如 <code>obj.1</code></li>
</ul>
</li>
<li>使用中括號與字串來取值 <code>[&#39;屬性名稱&#39;]</code>，<ul>
<li>可以利用變數名稱帶入</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  fn()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我是函式&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj<span class="number">.1</span>) <span class="comment">// 報錯 Unexpected number </span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;1&#x27;</span>]) <span class="comment">// 1，使用中括號與字串就能正確取值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fn()) <span class="comment">// &#x27;我是函式&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;fn&#x27;</span>]()) <span class="comment">// &#x27;我是函式&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[b]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>一樣可以透過點記號與中括號新增值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.cat = <span class="string">&#x27;阿美&#x27;</span></span><br><span class="line">obj[<span class="string">&#x27;dog&#x27;</span>] = <span class="string">&#x27;小黑&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="刪除"><a href="#刪除" class="headerlink" title="刪除"></a>刪除</h3><ul>
<li>物件屬性可以經由 <code>delete</code> 刪除</li>
<li>但已宣告的變數無法透過 <code>delete</code> 刪除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo = &#123;&#125;</span><br><span class="line">zoo.cat = <span class="string">&#x27;阿美&#x27;</span></span><br><span class="line">zoo[<span class="string">&#x27;dog&#x27;</span>] = <span class="string">&#x27;小黑&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> zoo.cat</span><br><span class="line"><span class="keyword">delete</span> zoo[<span class="string">&#x27;dog&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(zoo) <span class="comment">// &#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物件屬性可以被刪除、已宣告的變數不行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> zoo.cat) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> zoo[<span class="string">&#x27;dog&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> zoo) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="物件與純值"><a href="#物件與純值" class="headerlink" title="物件與純值"></a>物件與純值</h2><p>物件可以新增純值，但純值無法新增屬性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">&#x27;阿美&#x27;</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;&#125;</span><br><span class="line">zoo.cat = cat</span><br><span class="line">cat.dog = <span class="string">&#x27;小黑&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(zoo) <span class="comment">// &#123; cat:&#x27;阿美&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(cat) <span class="comment">// &#x27;阿美&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="物件與預設值"><a href="#物件與預設值" class="headerlink" title="物件與預設值"></a>物件與預設值</h2><p>所有的變數在建立的時候，JS均會給予一個 <code>undefined</code> 的值，當我們賦予這個變數值時，才會是正常看到的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a </span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(e) <span class="comment">// e is not defined</span></span><br><span class="line"><span class="comment">// 在呼叫變數 e 時，就會因為 e is not defined而中斷執行</span></span><br><span class="line"><span class="comment">// 可以透過物件取值的方式， window.e 讓執行可以繼續</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 當第一行為 window.e，會得到 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c) <span class="comment">// 當第一行為 window.e， 會得到 undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="物件傳參考"><a href="#物件傳參考" class="headerlink" title="物件傳參考"></a>物件傳參考</h2><p>只要看到大括號 <code>&#123;&#125;</code> ，就會與原來的物件區隔開來。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 賦予純值</span></span><br><span class="line"><span class="keyword">let</span> objA = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = objA</span><br><span class="line">b.x = <span class="number">2</span> </span><br><span class="line"><span class="built_in">console</span>.log(objA.x) <span class="comment">// 2，objA.a的值會被修改</span></span><br><span class="line"><span class="built_in">console</span>.log(b === objA) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 賦予物件，參考位置已被區隔</span></span><br><span class="line"><span class="keyword">let</span> objB = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = objB</span><br><span class="line">c = &#123; </span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(objB.x) <span class="comment">// 1，objB.a的值不會被修改</span></span><br><span class="line"><span class="built_in">console</span>.log(c === objB) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="物件複製"><a href="#物件複製" class="headerlink" title="物件複製"></a>物件複製</h2><h3 id="Call-by-Reference-與-Call-by-Sharing"><a href="#Call-by-Reference-與-Call-by-Sharing" class="headerlink" title="Call by Reference 與 Call by Sharing"></a>Call by Reference 與 Call by Sharing</h3><p>在 JS中，物件是 Call by Reference 還是 Call by Sharing ?<br>在維基百科的求值策略中提到，JS的物件是屬於 Call by Sharing，但在取值與賦予值的過程中反而會讓人認為是其他概念。那麼，根據目的而分類它是那一種效果，而非一定是屬於那一種效果，或許比較容易理解這些概念。</p>
<h4 id="Call-by-Reference"><a href="#Call-by-Reference" class="headerlink" title="Call by Reference"></a>Call by Reference</h4><p>將原物件賦予至新變數上，修改其值後，原物件也一併被修改，因為它們參照同一個位址上的物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refit = <span class="function">(<span class="params">car, color</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newColor = car</span><br><span class="line">  newColor.color = color</span><br><span class="line">  <span class="keyword">return</span> newColor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> carA = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> carB = refit(carA, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(carA, carB)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &quot;white&quot;</span></span><br><span class="line"><span class="comment">// &#125; Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &quot;white&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(carA === carB) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Call-by-Sharing"><a href="#Call-by-Sharing" class="headerlink" title="Call by Sharing"></a>Call by Sharing</h4><p>將物件複製後，修改其值，不會將原來的物件一併修改，因為使用了新物件做區隔。但這屬於淺層複製，後面會有淺層與深層複製的介紹。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refit = <span class="function">(<span class="params">car, color</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Object.assign(&#123;&#125;, 物件)</span></span><br><span class="line">  <span class="comment">// 複製目標物件的所有屬性至空物件</span></span><br><span class="line">  <span class="comment">// 也可以將多個物件屬性合併</span></span><br><span class="line">  <span class="keyword">let</span> newColor = <span class="built_in">Object</span>.assign(&#123;&#125;, car)</span><br><span class="line">  newColor.color = color</span><br><span class="line">  <span class="keyword">return</span> newColor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> carA = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> carB = refit(carA, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(carA, carB)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &quot;white&quot;</span></span><br><span class="line"><span class="comment">// &#125; Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(carA === carB) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="Call-by-Value"><a href="#Call-by-Value" class="headerlink" title="Call by Value"></a>Call by Value</h4><p><strong>複製</strong> x的值給 y，y 重新賦予值不會修改 x的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = x</span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="淺層與深層複製"><a href="#淺層與深層複製" class="headerlink" title="淺層與深層複製"></a>淺層與深層複製</h3><p>在上面的範例中，有使用到 <code>Object.assign()</code> 來複製物件內容，但這樣只有複製了第一層，若其中某個屬性值也是物件，也就是原物件的子物件，當修改這個子物件時，還是會修改到原物件的子內容。</p>
<h4 id="淺層複製-shallow-copy"><a href="#淺層複製-shallow-copy" class="headerlink" title="淺層複製 shallow copy"></a>淺層複製 shallow copy</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> carA = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  other: &#123;</span><br><span class="line">    door: <span class="number">4</span>,</span><br><span class="line">    SRS: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一種方式 for in</span></span><br><span class="line"><span class="keyword">let</span> newCar = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> carA)&#123;</span><br><span class="line">  newCar[key] = carA[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二種方式 jQuery</span></span><br><span class="line"><span class="comment">// let newCar = jQuery.extend(true, &#123;&#125;, carA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三種方式 ES6</span></span><br><span class="line"><span class="comment">// let newCar = Objecct.assign(&#123;&#125;, carA)</span></span><br><span class="line"></span><br><span class="line">newCar.other.SRS = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(carA, newCar)</span><br><span class="line"><span class="comment">// 原物件的子物件也一併被修改</span></span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &#x27;white&#x27;</span></span><br><span class="line"><span class="comment">//   other: &#123;</span></span><br><span class="line"><span class="comment">//     door: 4,</span></span><br><span class="line"><span class="comment">//     SRS: 1</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Object&#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &#x27;white&#x27;</span></span><br><span class="line"><span class="comment">//   other: &#123;</span></span><br><span class="line"><span class="comment">//     door: 4,</span></span><br><span class="line"><span class="comment">//     SRS: 1</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(carA === newCar) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="深層複製-deep-copy"><a href="#深層複製-deep-copy" class="headerlink" title="深層複製 deep copy"></a>深層複製 deep copy</h4><p>藉由 JSON轉字串( <code>JSON.stringify(物件)</code> )再轉回物件( <code>JSON.parse(JSON字串)</code> )，就能完全複製出一個新物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> carA = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  other: &#123;</span><br><span class="line">    door: <span class="number">4</span>,</span><br><span class="line">    SRS: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCar = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(carA))</span><br><span class="line"></span><br><span class="line">newCar.other.SRS = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(carA, newCar)</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &#x27;white&#x27;</span></span><br><span class="line"><span class="comment">//   other: &#123;</span></span><br><span class="line"><span class="comment">//     door: 4,</span></span><br><span class="line"><span class="comment">//     SRS: 2</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Object&#123;</span></span><br><span class="line"><span class="comment">//   age: 20,</span></span><br><span class="line"><span class="comment">//   color: &#x27;white&#x27;</span></span><br><span class="line"><span class="comment">//   other: &#123;</span></span><br><span class="line"><span class="comment">//     door: 4,</span></span><br><span class="line"><span class="comment">//     SRS: 1</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(carA === newCar) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不過，使用 JSON互轉的方式會遇到一些問題，像是屬性值若為函式、undefined會消失，Nan則為 null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> motorcycle = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Z900RS&#x27;</span>,</span><br><span class="line">  equipped: &#123;</span><br><span class="line">    headlight: <span class="string">&#x27;round&#x27;</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  fn()&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  un: <span class="literal">undefined</span>, </span><br><span class="line">  nan: <span class="literal">NaN</span>, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newMotorcycle = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(motorcycle))</span><br><span class="line"><span class="built_in">console</span>.log(newMotorcycle)</span><br><span class="line"><span class="comment">// Object&#123;</span></span><br><span class="line"><span class="comment">//   name: &#x27;Z900RS&#x27;,</span></span><br><span class="line"><span class="comment">//   equipped: &#123;</span></span><br><span class="line"><span class="comment">//     headlight: &#x27;round&#x27; </span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   nan: null</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br></pre></td></tr></table></figure>

<h4 id="第三方插件的深層複製"><a href="#第三方插件的深層複製" class="headerlink" title="第三方插件的深層複製"></a>第三方插件的深層複製</h4><p>能深層複製且沒有上述問題的方式，目前找到的有以下，經過 codePen測試(在 JS設定中匯入 CDN)，可以深層複製也沒有假值的問題。</p>
<ul>
<li>jQuery<ul>
<li><code>jQuery.extend(true, &#123;&#125;, 目標物件)</code></li>
<li><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js</code></li>
</ul>
</li>
<li>lodash<ul>
<li><code>_.cloneDeep(objects)</code></li>
<li><code>https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js</code></li>
</ul>
</li>
</ul>
<h4 id="非第三方插件之深層複製"><a href="#非第三方插件之深層複製" class="headerlink" title="非第三方插件之深層複製"></a>非第三方插件之深層複製</h4><p>若不依靠第三方插件，想自己動手試著複製，需要考慮到以下幾點，或者更多 : </p>
<ul>
<li>判斷型別，typeof </li>
<li>循環引用，callback</li>
<li>建構式</li>
<li>假值判斷</li>
<li>物件相依關係</li>
</ul>
<p>這邊附上測試後的確可運作的實例做為參考，<a href="https://ithelp.ithome.com.tw/articles/10223178">Gary - 14. [JS] 深拷貝是什麼？如何實現？</a>。</p>
<h2 id="物件與陣列"><a href="#物件與陣列" class="headerlink" title="物件與陣列"></a>物件與陣列</h2><ul>
<li>物件、函式、陣列的型別都是屬於 <code>object</code></li>
<li>陣列使用中括號 [ ]</li>
<li>每個索引位址都能賦予純值、物件、陣列、函式、布林值等</li>
<li>可以新增屬性，但不影響原有陣列長度</li>
<li>可以跳過索引賦予值，但是會有空的索引位置，預設為 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, , <span class="string">&#x27;3&#x27;</span>, fn, <span class="literal">true</span>, , [], &#123;&#125;]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>


<h2 id="物件與JSON"><a href="#物件與JSON" class="headerlink" title="物件與JSON"></a>物件與JSON</h2><ul>
<li>轉成字串時，屬性會使用雙引號 <code>&quot;屬性名稱&quot;</code></li>
<li>撰寫 JSON格式時，無法使用物件的形式撰寫，也就是說屬性名稱必須要有單或雙引號</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-call-by-value-%E9%82%84%E6%98%AFreference-%E5%8F%88%E6%88%96%E6%98%AF-sharing-22a87ca478fc">Charles Huang - JS基本觀念：call by value 還是reference 又或是 sharing?</a></li>
<li><a href="https://hsiangfeng.github.io/javascript/20200904/1772972600/">Ray - JavaScript 核心觀念(29)-物件-Call by Reference 還是 Call by Sharing</a></li>
<li><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">huli - 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5">wikipedia - 求值策略</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN - Object.assign()</a></li>
<li><a href="https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax">stackoverflow - Deep copy in ES6 using the spread syntax</a></li>
<li><a href="https://api.jquery.com/jquery.extend/">jQuery - jQuery.extend()</a></li>
<li><a href="https://lodash.com/docs/4.17.15#cloneDeep">lodash - _.cloneDeep(value)</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10223178">Gary - 14. [JS] 深拷貝是什麼？如何實現？</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>迴圈之變數作用域</title>
    <url>/2020/11/13/javascript/%E8%BF%B4%E5%9C%88%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>很多技術筆記說明 JS變數的作用域時，都會使用迴圈與一個 JS內建函式來說明作用域的不同之處，但為什麼使用了 <code>setTimeout()</code> 這個語法，可以讓結果不同?<br>主要是因為以下的運作方式與觀念，會讓結果不同 : </p>
<ul>
<li>變數宣告影響作用域</li>
<li>執行緒</li>
<li>Callback Function </li>
</ul>
<h2 id="迴圈與變數作用域"><a href="#迴圈與變數作用域" class="headerlink" title="迴圈與變數作用域"></a>迴圈與變數作用域</h2><p>在以下的例子中，是最常見的 for迴圈，使用不同的變數宣告方式並印出結果，而迴圈宣告的變數會建立在不同地方，假設宣告變數在在全域環境中，那麼</p>
<ul>
<li>使用 var宣告的變數，被建立在全域環境底下。</li>
<li>使用 let宣告的變數，被建立在獨立的區塊中，也就是該函式的執行環境。</li>
</ul>
<h3 id="直接印出迴圈結果"><a href="#直接印出迴圈結果" class="headerlink" title="直接印出迴圈結果"></a>直接印出迴圈結果</h3><ul>
<li>執行結果看不出差異</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span> ; y &lt; <span class="number">5</span> ; y++) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 結果都是</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="一秒後印出所有結果"><a href="#一秒後印出所有結果" class="headerlink" title="一秒後印出所有結果"></a>一秒後印出所有結果</h3><ul>
<li>使用 JS內建函式 <code>setTimeout()</code>，卻讓執行結果改變。</li>
</ul>
<ol>
<li>使用 var宣告變數<ul>
<li>var的最小作用域為 function</li>
<li>在全域環境下，for迴圈每跑一次，事件佇列就會多一個 <code>setTimeout()</code>，當 for迴圈跑完換事件佇列內的 <code>setTimeout()</code> 執行時，i 已經改變成 5 了，所以會有五個 5。</li>
<li><strong>但是，為什麼結果是 5 不是 4 ?</strong></li>
<li>i 已經在全域環境下建立了，也因此執行第一次迴圈時，i++的關係，i 就變成了 1，總共要執行五次，所以 i 為 5。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 let宣告變數<ul>
<li>let的最小作用域為 <code>&#123; &#125;</code> ，例如 <code>for()&#123;&#125;</code>、<code>if()&#123;&#125;</code></li>
<li>每當進入事件佇列時，當下的 y 值會跟著進去</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span> ; y&lt;<span class="number">5</span> ; y++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上述的例子，有說到 <code>setTimeout()</code> 會進入<strong>事件佇列</strong>，接著因變數宣告方式不同會改變結果，這跟接下來的說明有關。</p>
<h2 id="Callback-Function-與執行緒"><a href="#Callback-Function-與執行緒" class="headerlink" title="Callback Function 與執行緒"></a>Callback Function 與執行緒</h2><p>函式的參數不僅可以放單一值、陣列以及物件，也可以放函式，而 JS的執行方式會影響函式的運作時機。</p>
<h3 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h3><ul>
<li>某個函式做為另一個函式的參數值。</li>
<li>例如 <code>setTimeout()</code> <ul>
<li><code>setTimeout( 某函式, 等待多久後印出的時間 )</code></li>
<li><code>setTimeout( function(), 1000 )</code></li>
<li>若依賴其他函式過深，也就是重複這種型態，就會變成所謂的波動拳。</li>
<li>衍伸出 <strong>Promise</strong> 的概念。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout()，1秒後印出該函式的結果</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Callback Function&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// &quot;Callback Function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="執行緒"><a href="#執行緒" class="headerlink" title="執行緒"></a>執行緒</h3><ul>
<li>JS執行方式為單線程</li>
<li>執行過程<ul>
<li>由上到下執行。</li>
<li>執行函式時，會先放進執行堆疊，直到 return結果後離開(以下範例用 <code>console.log()</code> 代替)。</li>
<li>執行<strong>事件</strong>時，會等待被觸發，例如點擊，計時器之類的事件，它們會暫時在瀏覽器中等待。</li>
<li>當事件被觸發時， JS會將它要執行的函式放進事件佇列，等執行堆疊的函式處理完畢後，再處理佇列內的函式。</li>
<li>為什麼會有事件?<ul>
<li><code>setTimeout()</code>，可以寫成 <code>window.setTimeout()</code>，也就是說，事件是瀏覽器的 API給 JS使用的。</li>
</ul>
</li>
<li>程式碼的事件 &gt; 等待觸發 &gt; 觸發 &gt; 事件佇列</li>
</ul>
</li>
</ul>
<h4 id="測試範例"><a href="#測試範例" class="headerlink" title="測試範例"></a>測試範例</h4><ul>
<li>測試一</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由上到下執行，函式執行後進入執行堆疊，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line">fnB()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試二</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在另一個函式內執行函式，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">  fnB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試三</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在另一個函式內執行函式，產生結果後離開</span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 B&quot;，接著產生 &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fnB()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>

<ul>
<li>測試四</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函式內執行事件 setTimeout() </span></span><br><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 A&quot;，接著 3秒後產生 &quot;我是函式 B&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(fnB, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 結果與預期相同</span></span><br></pre></td></tr></table></figure>
<ul>
<li>測試五<ul>
<li>JS的執行方式若遇到事件時，會等待事件觸發。</li>
<li>直到執行堆疊處理完畢後，看事件是否觸發，若觸發則放入事件佇列中並執行事件內的函式。</li>
<li>也就是說，無論 <code>setTimeout()</code> 秒數設為 0秒還是3秒，都會先等待觸發並往下處理執行堆疊內的函式。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 預期結果為 &quot;我是函式 B&quot;，接著 3秒後產生 &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fnB, <span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"><span class="comment">// 與預期結果不同 !!!</span></span><br><span class="line"><span class="comment">// &quot;我是函式 A&quot;</span></span><br><span class="line"><span class="comment">// &quot;我是函式 B&quot; &lt;- 3秒後產生</span></span><br></pre></td></tr></table></figure>

<h2 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h2><p>以下面兩個例子來說，它包含了 : </p>
<ul>
<li>var的作用域<ul>
<li>用 function區隔會有不同結果，可以做到與 let相同的事。</li>
</ul>
</li>
<li>執行緒<ul>
<li>函式的執行堆疊與事件觸發之事件佇列(等待)。</li>
</ul>
</li>
<li>Callback Function<ul>
<li>在 <code>setTimeout()</code> 中執行另一個函式。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數 z已被 function區隔，因此全域環境中是找不到 z這個變數的，</span></span><br><span class="line"><span class="comment">// 但它還是會存在於函式 fnA內，</span></span><br><span class="line"><span class="comment">// 秒數的 z值屬於 setTimeout 這個函式，也因此被區隔，</span></span><br><span class="line"><span class="comment">// 進入事件佇列後，console.log(z) 執行的是函式 fnA的 z值，也就是 5。</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span> ; z &lt; y ; z++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(z)          </span><br><span class="line">   &#125;, <span class="number">1000</span>*z)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A，接著執行函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnA(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 變數 z的值，隨著函式 fnB進入了執行堆疊，</span></span><br><span class="line"><span class="comment">// 執行堆疊內，函式執行了事件，等待事件觸發後，z值一起進入了事件佇列中，</span></span><br><span class="line"><span class="comment">// z值待在 fnB的區塊中，此時 console.log(x) 執行的是函式 fnB所帶來的值。</span></span><br><span class="line"><span class="comment">// 閉包的概念</span></span><br><span class="line"><span class="keyword">const</span> fnA = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span> ; z &lt; y ; z++) &#123;</span><br><span class="line">    fnB(z)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是函式 A，接著執行函式 B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fnB = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x)          </span><br><span class="line">  &#125;, <span class="number">1000</span>*x)</span><br><span class="line">&#125; </span><br><span class="line">fnA(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="延伸概念"><a href="#延伸概念" class="headerlink" title="延伸概念"></a>延伸概念</h3><ul>
<li>閉包</li>
<li>Promise</li>
<li>同步與非同步</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10192739">Kuro Hsu - 重新認識 JavaScript: Day 18 Callback Function 與 IIFE</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10193009">Kuro Hsu - 重新認識 JavaScript: Day 19 閉包 Closure</a></li>
<li><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">PJCHENder那些沒告訴你的小細節 - [筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 運算子</title>
    <url>/2020/11/20/javascript/%E9%81%8B%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<h2 id="運算子"><a href="#運算子" class="headerlink" title="運算子"></a>運算子</h2><p>舉凡加減乘除都是運算子，等號也是運算子之一。<br>(詳細可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators">MDN-運算子</a>)。</p>
<ul>
<li>運算子均為表達式，一定會回傳值</li>
<li>一元運算子<ul>
<li><code>let a = 1</code></li>
</ul>
</li>
<li>二元運算子<ul>
<li><code>let b = 1 + 2</code></li>
</ul>
</li>
<li>三元運算子<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(c ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>物件增加屬性的方法 <code>.</code> ，也是一個運算子，<code>.</code>、<code>[]</code> 在運算子中為<strong>最優先</strong>。</li>
</ul>
<h3 id="優先性、相依性"><a href="#優先性、相依性" class="headerlink" title="優先性、相依性"></a>優先性、相依性</h3><ul>
<li>運算子有其優先順序<ul>
<li>乘除的優先序大於加減的優先序</li>
</ul>
</li>
<li>相依性則決定了運算方向<ul>
<li>絕大多數的運算子都是從左至右</li>
<li>等號賦值為從右至左</li>
</ul>
</li>
<li>經典題目 : <code>6/2(2+1) = ?</code></li>
</ul>
<h4 id="比較運算子"><a href="#比較運算子" class="headerlink" title="比較運算子"></a>比較運算子</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 從左至右，逐一比較</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 3 &gt; 2 為 true</span></span><br><span class="line"><span class="comment">// true &gt; 1 為 false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &gt; <span class="number">2</span> &gt; <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1 &lt; 2 為 false</span></span><br><span class="line"><span class="comment">// false &gt; 3 為 false</span></span><br></pre></td></tr></table></figure>
<h4 id="賦值運算子"><a href="#賦值運算子" class="headerlink" title="賦值運算子"></a>賦值運算子</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 從右至左，逐一賦值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a = b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<h4 id="Member-Access"><a href="#Member-Access" class="headerlink" title="Member Access ."></a>Member Access <code>.</code></h4><p>這縮寫為點的運算子，可以尋找/賦予物件的屬性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 物件屬性賦值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.defineProperty 可以定義物件中某個屬性的內建屬性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">b = obj.a </span><br><span class="line">obj.c = b = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a, b, obj.c)</span><br><span class="line"><span class="comment">// 3 5 5</span></span><br><span class="line"><span class="comment">// obj.a 無法被修改</span></span><br><span class="line"><span class="comment">// b 再度被&quot;賦予值&quot; </span></span><br><span class="line"><span class="comment">// 依據運算子的優先順序，物件的成員也就是屬性，它的優先順序大於等號</span></span><br><span class="line"><span class="comment">// 物件 obj，會先建立了 c這個屬性，之後才被等號賦予值</span></span><br></pre></td></tr></table></figure>

<h4 id="物件傳參考賦予值"><a href="#物件傳參考賦予值" class="headerlink" title="物件傳參考賦予值"></a>物件傳參考賦予值</h4><p>運算子與物件傳參考綜合使用。</p>
<ol>
<li>物件 e會先建立屬性名稱 x</li>
<li>接著依照等號運作從右至左賦值</li>
<li>物件 e另開了一個位址</li>
<li>原先的物件 e的確有新增屬性名稱 x，且被賦予物件</li>
<li>原先的物件 e依然被 f參考</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> e = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> f = e</span><br><span class="line">e.x = e = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(e.x) </span><br><span class="line"><span class="built_in">console</span>.log(e.q) </span><br><span class="line"><span class="built_in">console</span>.log(f.x)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined 物件已存在，可以直接增加屬性名稱</span></span><br><span class="line"><span class="comment">// 呼叫 e.q時，不會是 &#x27;q is not defined&#x27;，所以呼叫 e.x也是一樣的，只不過物件 e已新開參考位址</span></span><br><span class="line"><span class="comment">// &#123;x:2&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="寬鬆與嚴謹模式"><a href="#寬鬆與嚴謹模式" class="headerlink" title="寬鬆與嚴謹模式"></a>寬鬆與嚴謹模式</h3><p>一個等號為賦值，兩個等號為寬鬆判斷，三個等號為嚴謹判斷。</p>
<ul>
<li>寬鬆判斷<ul>
<li>當兩者型別不同時，JS會嘗試轉換型別。</li>
</ul>
</li>
<li>嚴謹判斷<ul>
<li>當兩者型別不同時，JS不會轉換型別。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">1</span>)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="string">&#x27;1&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> != <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> !== <span class="string">&#x27;1&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="隱藏型別-自動轉型"><a href="#隱藏型別-自動轉型" class="headerlink" title="隱藏型別 / 自動轉型"></a>隱藏型別 / 自動轉型</h3><p>在判斷是否相等時，根據模式 JS會將型別自動轉型(踩地雷~砰!)。</p>
<h4 id="寬鬆判斷時"><a href="#寬鬆判斷時" class="headerlink" title="寬鬆判斷時"></a>寬鬆判斷時</h4><ul>
<li>字串與數字</li>
<li>布林與數字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字串與數字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> == <span class="number">1</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>) <span class="comment">// &#x27;Y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布林與數字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">1</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>) <span class="comment">// &#x27;Y&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">0</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>) <span class="comment">// &#x27;N&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="number">0</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>) <span class="comment">// &#x27;Y&#x27;</span></span><br><span class="line"><span class="comment">// JS會嘗試將布林值轉成數字</span></span><br><span class="line"><span class="comment">// Number(true)，1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字串與數字 ???</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;false&#x27;</span> == <span class="number">0</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>) <span class="comment">// &#x27;N&#x27;</span></span><br><span class="line"><span class="comment">// JS會嘗試將字串轉成數字</span></span><br><span class="line"><span class="comment">// Number(&#x27;false&#x27;)，NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="算數運算子"><a href="#算數運算子" class="headerlink" title="算數運算子"></a>算數運算子</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> + <span class="number">1</span>) <span class="comment">// 字串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>) <span class="comment">// 數字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> * <span class="number">2</span>) <span class="comment">// 數字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> / <span class="number">2</span>) <span class="comment">// 數字</span></span><br></pre></td></tr></table></figure>

<h4 id="包裹物件"><a href="#包裹物件" class="headerlink" title="包裹物件"></a>包裹物件</h4><p>它們的型別為物件，JS在寬鬆相等判斷時會利用這些來轉型，像是這些 : </p>
<ul>
<li>Number()</li>
<li>String()</li>
<li>Boolean()</li>
</ul>
<hr>
<h3 id="Truthy-amp-Falthy"><a href="#Truthy-amp-Falthy" class="headerlink" title="Truthy &amp; Falthy"></a>Truthy &amp; Falthy</h3><p>這邊指得是在某個函式中的參數，若放入以下其中一種<strong>單一值</strong>，其值被判定後的結果，與相等判斷、邏輯判斷概念不太一樣。</p>
<ul>
<li>參數其值為單一數字、字串、物件、陣列、建構函式、Infinity、-Infinity以及 <code>true</code>，均為<strong>真值</strong>。</li>
<li>參數其值為 <code>false</code>、<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 均為<strong>假值</strong>。</li>
<li>也就是說，除了假值之外，其餘均為真值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span> <span class="comment">// 可自由替換</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;被判定為 true，故為真值&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;被判定為 false，故為假值&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(x))</span><br></pre></td></tr></table></figure>

<h3 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子"></a>邏輯運算子</h3><p>共有三種，優先順序為 <code>!</code> 大於 <code>&amp;&amp;</code> 大於 <code>||</code>，相依性為由左至右，而且在邏輯判斷時，<strong>型別不會自動轉換。</strong></p>
<h4 id="AND-amp-amp"><a href="#AND-amp-amp" class="headerlink" title="AND &amp;&amp;"></a>AND <code>&amp;&amp;</code></h4><ul>
<li>當前者可被轉型成 false時，會回傳前者結果</li>
<li>若否，回傳後者結果</li>
<li>也因此若兩者皆為布林值，根據規則剛好與”真值表”相同</li>
</ul>
<h4 id="OR"><a href="#OR" class="headerlink" title="OR ||"></a>OR <code>||</code></h4><ul>
<li>當前者可被轉型成 true，會回傳前者結果</li>
<li>若否，回傳後者結果</li>
<li>也因此若兩者皆為布林值，根據規則剛好與”真值表”相同</li>
</ul>
<h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT !"></a>NOT <code>!</code></h4><ul>
<li>會將布林值反轉</li>
<li>可以將 Truthy &amp; Falthy的結果反轉</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AND `&amp;&amp;`</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">0</span> &amp;&amp; <span class="number">1</span>)        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="number">1</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> &amp;&amp; <span class="number">1</span>&lt;<span class="number">2</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">1</span>)       <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">true</span> &amp;&amp; <span class="number">3</span>&gt;<span class="number">2</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">3</span>&gt;<span class="number">2</span> &amp;&amp;  <span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OR `||`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> || <span class="number">1</span>)         <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0&#x27;</span> || <span class="number">1</span>)       <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> || <span class="number">1</span>&lt;<span class="number">2</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&#x27;&#x27;</span> || <span class="literal">null</span>)    <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">true</span> || <span class="number">3</span>&gt;<span class="number">2</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> || <span class="number">3</span>&gt;<span class="number">2</span> ) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT `!`</span></span><br><span class="line"><span class="built_in">console</span>.log( !<span class="number">1</span> || <span class="number">2</span>)      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log( !<span class="literal">null</span> || <span class="number">2</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( !<span class="literal">null</span> &amp;&amp; !<span class="string">&#x27;&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( !<span class="literal">null</span> &amp;&amp; [])  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h3 id="綜合練習-函式預設值"><a href="#綜合練習-函式預設值" class="headerlink" title="綜合練習 - 函式預設值"></a>綜合練習 - 函式預設值</h3><p>請修改以下函式，當函式未給值時，不讓它成為假值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">500</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  x += y</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`本次儲存 <span class="subst">$&#123;y&#125;</span> 元!，您共有 <span class="subst">$&#123;x&#125;</span> 元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() </span><br><span class="line"><span class="comment">// 本次儲存 undefined 元!，您共有 NaN 元。&quot;</span></span><br><span class="line"><span class="comment">// undefined，其為函式參數預設值</span></span><br><span class="line"><span class="comment">// 數值與 undefined相加，會變成 NaN</span></span><br></pre></td></tr></table></figure>

<p>修改函式後</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">500</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">  y = (y || y === <span class="number">0</span>) ? y: <span class="number">500</span>;</span><br><span class="line">  x += y</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`本次儲存 <span class="subst">$&#123;y&#125;</span> 元!，您共有 <span class="subst">$&#123;x&#125;</span> 元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() </span><br><span class="line"><span class="comment">// &quot;本次儲存 500 元!，您共有 1000 元。&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li>六角學院 JS核心篇 - 運算子章節</li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN - Object.defineProperty()</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">MDN - Truthy（真值）</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Default_parameters">MDN - 預設參數( Default parameters )</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10192342">SimonAllen - Day17 傳值by value與傳址by reference</a></li>
<li><a href="https://medium.com/@yining1204/javascript-%E6%A0%B8%E5%BF%83%E7%AF%87-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-chap-33-%E6%9C%AA%E5%AE%9A%E7%BE%A9%E7%9A%84%E7%89%A9%E4%BB%B6%E5%B1%AC%E6%80%A7%E9%A0%90%E8%A8%AD%E5%80%BC-59406399c521">Yi-Ning - JavaScript 核心篇 學習筆記: Chap.33 — 未定義的物件屬性預設值</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10205918">Jimmy - Day 13 物件與點</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10191343">Kuro Hsu - 重新認識 JavaScript: Day 08 Boolean 的真假判斷</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法入門(一) 演算法與大 O 符號</title>
    <url>/2020/10/19/%E6%BC%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%96%80/%E6%BC%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%96%80(%E4%B8%80)%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E5%A4%A7%20O%20%E7%AC%A6%E8%99%9F/</url>
    <content><![CDATA[<h2 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h2><blockquote>
<p>演算法三步驟，它是明確的、有限的且有效率的</p>
</blockquote>
<ol>
<li>輸入</li>
<li>計算步驟</li>
<li>輸出</li>
</ol>
<h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>假設現在目標是砍倒一棵樹，且不限時間，使用斧頭會需要很多時間也浪費力氣，使用電鋸省力也省時，換成步驟來看的話，斧頭需要很多砍很多下才會倒，且需要的時間非常多，換成電鋸後，省時省力。</p>
<p>再假設你買了一部90萬的車輛，朋友問你這部車買了多少? 你只能打字回答，這時你會怎麼回覆呢? 9000百元? 900千元?  或者90萬元? 顯然是90萬元最符合答案也能最快回答。</p>
<h2 id="如何描述程式中時間與空間的關係呢"><a href="#如何描述程式中時間與空間的關係呢" class="headerlink" title="如何描述程式中時間與空間的關係呢?"></a>如何描述程式中時間與空間的關係呢?</h2><p>我們會以數學符號之<strong>漸進符號</strong> $O$，其表示為函數增長關係。</p>
<ul>
<li>漸進符號 $O$<ul>
<li>bigO，通常會寫成 $O()$</li>
</ul>
</li>
<li>時間複雜度<ul>
<li>隨著輸入值成長之執行步驟</li>
</ul>
</li>
<li>空間複雜度<ul>
<li>隨著輸入值成長之記憶體暫用空間</li>
</ul>
</li>
</ul>
<p>而通常我們為了簡化表達方式，會取其極限值，以下為一些例子 :</p>
<ul>
<li>常數 $\rightarrow$ 1</li>
<li>$n、2n、3n \rightarrow n$</li>
<li>$n^2+2n \rightarrow n^2$</li>
<li>以此類推</li>
</ul>
<h2 id="執行複雜度表示方式"><a href="#執行複雜度表示方式" class="headerlink" title="執行複雜度表示方式"></a>執行複雜度表示方式</h2><p>來看以下的例子，小杰被師父指派去賣漢堡，每個漢堡50元 :</p>
<ul>
<li><p>範例一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sell = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> total = n*<span class="number">50</span></span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函式一共執行 2個步驟，也就是說輸入無窮大時，也只會執行 2個步驟，那麼它的時間複雜度則為 $O(1)$，空間複雜度為 $O(1)$，因為只使用了 total這個變數。</p>
</li>
<li><p>範例二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sell = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> total = n*<span class="number">50</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`小杰累計賣出<span class="subst">$&#123;i&#125;</span>個漢堡~`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line">sell(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>for迴圈執行了 n次再加上前後兩個步驟共 n+2次，以時間複雜度來表示則為 $O(n)$，空間複雜度為 $O(1)$，使用了 total與 i兩個變數</p>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li><a href="https://break0344.medium.com/data-structures-and-algorithms-0-720c04cb8082">Long - 用JavaScript學習資料結構與演算法</a></li>
<li><a href="https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%B3%95%E5%85%A5%E9%96%80-%E9%81%B8%E6%93%87%E6%8E%92%E5%BA%8F%E8%88%87%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B3%95-23d4bc7085ff">胡程維 - 初學者學演算法</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>演算法入門</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>演算法入門</tag>
      </tags>
  </entry>
  <entry>
    <title>JS核心篇-函式</title>
    <url>/2020/12/02/javascript/JS%E6%A0%B8%E5%BF%83%E7%AF%87-%E5%87%BD%E5%BC%8F/</url>
    <content><![CDATA[<p>若要有效的處理資料，就一定會用到函式，這篇記錄函式有怎樣的特性與閉包運用概念。<br>目前有整理到的如下 :</p>
<ul>
<li>函式型別</li>
<li>立即函式</li>
<li>函式的參數使用，不同的函式會有不同的內建關鍵字，常見的有<ul>
<li><code>arguments</code> (ES6箭頭函式則無此參數)</li>
<li><code>this</code> (ES6箭頭函式則無此參數)</li>
<li>自訂參數</li>
</ul>
</li>
<li>閉包<ul>
<li>範圍鏈</li>
<li>函式與提升 (Hoisting)</li>
<li>函式與變數利用</li>
<li>閉包的私有方法</li>
</ul>
</li>
</ul>
<h2 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h2><ul>
<li>使用 <code>function</code> 來宣告一個函式。</li>
<li>具名函式，宣告函式後，給定一個名稱以利後續呼叫。</li>
<li>匿名函式，宣告函式後，不須給定名稱，常用於立即函式與變數賦予值上。<ul>
<li>名稱要給也是可以，但通常不會這麼做。</li>
</ul>
</li>
<li>ES6中可以使用箭頭函式。</li>
<li>雖然型別為 <code>&quot;function&quot;</code>，但它其實是物件的一種。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 具名函式 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;具名函式&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fnA()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匿名函式 */</span></span><br><span class="line"><span class="keyword">var</span> fnB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;匿名函式&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fnB()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ES6箭頭函式 */</span></span><br><span class="line"><span class="keyword">let</span> fnC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;箭頭函式&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fnA) <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="函式與型別"><a href="#函式與型別" class="headerlink" title="函式與型別"></a>函式與型別</h2><p>通常我們會利用 <code>typeof()</code> 來檢查目前值為哪一種型別，若對函式做檢查，會得到 <code>&quot;function&quot;</code>，但很多技術文章都說，函式其實也是一種物件，那要怎麼知道它的確是物件的一種呢?</p>
<ul>
<li>利用物件原型方式看子型別為何，會得到 <code>&quot;[object Function]&quot;</code> 。</li>
<li>將函式當作物件新增屬性，console.log 可以正確取值。</li>
<li>將函式使用 <code>new</code> 這個運算子做為物件，可以在 console.log 的結果中往內層展開並找到新增的屬性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* typeof 型別檢查為 funciton */</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn) <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 利用物件原型來看函式屬於哪一種子型別 */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(fn))</span><br><span class="line"><span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype) <span class="comment">// Object &#123; 許多屬性 &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函式可以新增屬性 */</span></span><br><span class="line">fn.b = <span class="string">&#x27;新增屬性值&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.b) <span class="comment">// &#x27;新增屬性值&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 將函式以 new這個運算子，成為一個建構式函式 */</span></span><br><span class="line"><span class="comment">// 可以在原型物件(__proto__)底下的 constructor中，發現新增的屬性 b</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn&#123;</span></span><br><span class="line"><span class="comment">//   __proto__: &#123;</span></span><br><span class="line"><span class="comment">//     constructor: fn &#123;</span></span><br><span class="line"><span class="comment">//       b = &#x27;新增屬性值&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="立即函式"><a href="#立即函式" class="headerlink" title="立即函式"></a>立即函式</h2><ul>
<li>一般函式需要呼叫它才會執行<ul>
<li><code>函式名稱()</code></li>
</ul>
</li>
<li>立即函式會立刻執行，給定名稱沒有意義<ul>
<li><code>( 名稱()&#123;&#125; )()</code></li>
<li><code>( ()&#123;&#125; )()</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一般函式 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 立即函式 */</span></span><br><span class="line"><span class="comment">// 它會立刻執行，所以也可以寫成匿名函式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)(<span class="string">&#x27;函式&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 箭頭與立即 */</span></span><br><span class="line">( <span class="function"><span class="params">a</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(a)&#125; )(<span class="string">&#x27;函式&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函式與參數"><a href="#函式與參數" class="headerlink" title="函式與參數"></a>函式與參數</h2><p>一段函式中，常見的內建參數有以下這些 : </p>
<ul>
<li>arguments</li>
<li>this</li>
<li>自訂參數</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;全域物件中的變數&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span> , <span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;自訂參數&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;自訂參數&#x27;</span></span><br><span class="line"><span class="comment">// [&#x27;自訂參數&#x27;]，它為類陣列</span></span><br><span class="line"><span class="comment">// &#x27;全域物件中的變數&#x27;，為什麼不是 &#x27;自訂參數&#x27;，在後面 this會有說明</span></span><br></pre></td></tr></table></figure>

<h3 id="參數關鍵字-arguments"><a href="#參數關鍵字-arguments" class="headerlink" title="參數關鍵字 arguments"></a>參數關鍵字 arguments</h3><ul>
<li>能接收所有傳入的值</li>
<li>它為類陣列，也就說它沒有陣列的原型方法可以使用</li>
<li>其型別為 <code>&quot;object&quot;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// Arguments&#123; </span></span><br><span class="line"><span class="comment">//   [2, 4, 6],</span></span><br><span class="line"><span class="comment">//   callee: f sum(),</span></span><br><span class="line"><span class="comment">//   length: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="參數關鍵字-this"><a href="#參數關鍵字-this" class="headerlink" title="參數關鍵字 this"></a>參數關鍵字 this</h3><p>參考自己整理 this筆記，this在不同位置中會指向誰。</p>
<ul>
<li><a href="https://hsuan777.github.io/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8A/">箭頭函式與 this(上)</a></li>
<li><a href="https://hsuan777.github.io/2020/11/02/javascript/ES6%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E8%88%87this%E4%B8%8B/">箭頭函式與 this(下) - call、apply、bind</a></li>
</ul>
<h4 id="this-與簡易呼叫"><a href="#this-與簡易呼叫" class="headerlink" title="this 與簡易呼叫"></a>this 與簡易呼叫</h4><p>還記得 <code>this</code> 只看在哪裡被呼叫嗎? 又怎樣算是簡易呼叫(simple call)?<br>來看以下例子 : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;全域物件&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;函式內變數&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fnC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">  fnC()</span><br><span class="line">&#125;</span><br><span class="line">fnA() <span class="comment">// &#x27;全域物件&#x27;</span></span><br><span class="line">fnB() <span class="comment">// &#x27;全域物件&#x27;</span></span><br></pre></td></tr></table></figure>

<p>為什麼兩個都是指向全域?</p>
<ul>
<li><code>fnA()</code> 在全域環境中被呼叫，且函式在全域環境下被定義，這點很容易看出來，就算把 <code>this</code> 拿掉，也會尋找外層的變數 a。</li>
<li><code>fnB()</code> 被呼叫後，執行了 <code>fnC()</code> ，它明明在 <code>fnB()</code> 內被執行，為什麼 <code>this</code> 還是指向全域? 沒關係，繼續往下看另一個例子。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;全域物件&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">&#x27;物件屬性值&#x27;</span>,</span><br><span class="line">  fnA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125;,</span><br><span class="line">  fnB: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;函式內變數&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fnC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">    fnC()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fnA() <span class="comment">// &quot;物件屬性值&quot;</span></span><br><span class="line">obj.fnB() <span class="comment">// &quot;全域物件&quot;</span></span><br></pre></td></tr></table></figure>

<p>為什麼執行物件中的兩個函式，結果會不一樣，照理說要指向物件中的屬性 <code>obj.a</code> 吧?</p>
<ul>
<li>物件中的 <code>fnA()</code>，<code>this</code> 正確指向了該物件</li>
<li>物件中的 <code>fnB()</code> 執行後，再執行 <code>fnC()</code>，<code>this</code> 卻指向了全域物件?<ul>
<li>執行 <code>obj.fnA()</code> ，是由 <code>obj</code> 呼叫 <code>fnA()</code></li>
<li>執行 <code>obj.fnB()</code> ，是由 <code>obj</code> 呼叫 <code>fnB()</code>，接著執行 <code>fnC()</code> ，<br><code>fnC()</code> 被誰呼叫? 沒有，它是直接被執行的，所以它的 <code>this</code> 指向了全域。</li>
<li>若將 <code>fnC()</code> 內的 <code>this.a</code> 改為 <code>a</code>，則會因為範圍鏈的關係往外層尋找，就會是 <code>&#39;函式內變數&#39;</code>。</li>
</ul>
</li>
</ul>
<p>再來複習一下 <code>this</code> 與簡易呼叫。</p>
<ul>
<li>簡易呼叫是甚麼?<ul>
<li>直接呼叫，未透過任何方式取用執行。</li>
</ul>
</li>
<li>簡易呼叫為全域物件下的一種? <ul>
<li>否，是 <code>this</code> 會指向全域，而不是該函式被建立在在全域下</li>
</ul>
</li>
<li>那些例子屬於簡易呼叫?<ul>
<li>callback function </li>
<li>立即函式</li>
<li>原型方法，例如陣列的 <code>forEach</code>，此為繼承共用的原型方法，屬於直接執行。</li>
</ul>
</li>
</ul>
<p>那如果要將 <code>fnC()</code> ，正確的指向物件屬性 a呢 ? 來改寫上面的例子，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;全域物件&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">&#x27;物件屬性值&#x27;</span>,</span><br><span class="line">  fnA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125;,</span><br><span class="line">  fnB: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;函式內變數&#x27;</span></span><br><span class="line">    <span class="comment">// 這裡的 this 會指向該物件</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fnC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 閉包的原理，讓還需用到的變數，將它關在函式中，不被釋放</span></span><br><span class="line">      <span class="built_in">console</span>.log(vm.a)</span><br><span class="line">    &#125;</span><br><span class="line">    fnC()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fnA() <span class="comment">// &quot;物件屬性值&quot;</span></span><br><span class="line">obj.fnB() <span class="comment">// &quot;物件屬性值&quot;</span></span><br></pre></td></tr></table></figure>

<p>為什麼 <code>fnB()</code> 將 <code>this</code> 賦予給一個變數時，就不會指向全域，而是會指向物件呢?</p>
<ul>
<li><code>fnB()</code> ，是由物件 <code>obj</code> 所呼叫的，就跟 <code>fnA()</code> 一樣，他們的 <code>this</code> 都會指向該物件。</li>
<li>在 <code>fnB()</code> 內宣告一個變數，將指向物件的 <code>this</code> 賦予給該變數，<code>fnC()</code> 再利用此變數時，就會正確的指向物件 <code>obj</code>。</li>
<li>後面的段落會說明閉包的概念。</li>
</ul>
<h4 id="this-與DOM"><a href="#this-與DOM" class="headerlink" title="this 與DOM"></a>this 與DOM</h4><ul>
<li><code>console.dir</code> 可以看到它原本的物件有哪些屬性</li>
<li>可以使用 <code>this</code> 指向 DOM的單一元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="string">&#x27;某個標籤元素&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="this-與-call、apply、bind"><a href="#this-與-call、apply、bind" class="headerlink" title="this 與 call、apply、bind"></a>this 與 call、apply、bind</h4><ul>
<li>call與 apply會立刻執行，bind則需要呼叫。</li>
<li><strong>非嚴格模式傳入 <code>null</code>、<code>undefined</code>，則會指向全域物件</strong>。</li>
<li><code>this</code> 為物件型別，也就是說傳入後會變成包裹物件(建構式)。<ul>
<li>若傳入的是數字，會變成 <code>Number()</code></li>
<li>若傳入的是字串，會變成 <code>String()</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>+a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>+b)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">// Number 1 </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &quot;13&quot;</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">// Window </span></span><br><span class="line"><span class="comment">// &quot;[object Window]2&quot;</span></span><br><span class="line"><span class="comment">// &quot;[object Window]3&quot;</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="嚴格模式"><a href="#嚴格模式" class="headerlink" title="嚴格模式"></a>嚴格模式</h4><ul>
<li>加入 <code>use strict</code></li>
<li>不會影響不支援嚴格模式的瀏覽器</li>
<li>可依據執行環境設定 <code>use strict</code></li>
<li>透過拋出錯誤的方式消除ㄧ些安靜的錯誤(消除小錯誤)</li>
<li>禁止使用ㄧ些有可能被未來版本 ECMAScript定義的語法</li>
<li>在這些方法中的 <code>this</code> ，預設值是 <code>undefined</code>，若未傳入值又去呼叫它，就會是 <code>undefined</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="comment">// 在嚴格模式下的 call、apply、bind 不會變成建構式物件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>+a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>+b)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &quot;null3&quot;</span></span><br><span class="line"><span class="comment">// Cannot read property &#x27;c&#x27; of null </span></span><br></pre></td></tr></table></figure>

<h3 id="函式與自訂參數"><a href="#函式與自訂參數" class="headerlink" title="函式與自訂參數"></a>函式與自訂參數</h3><h4 id="參數傳入值"><a href="#參數傳入值" class="headerlink" title="參數傳入值"></a>參數傳入值</h4><ul>
<li>當函式執行時，只會根據位置傳入值</li>
<li>在函式中，參數所運用的地方才會是對應的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, d, e</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(d, e, a, b)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="參數傳入物件"><a href="#參數傳入物件" class="headerlink" title="參數傳入物件"></a>參數傳入物件</h4><p>當利用函式內的程式碼修改傳入的物件時，會依據傳參考特性修改原物件的屬性值，若物件在函式內做了深層複製的話則不會。</p>
<h4 id="參數傳入函式-callback-function"><a href="#參數傳入函式-callback-function" class="headerlink" title="參數傳入函式( callback function )"></a>參數傳入函式( callback function )</h4><p>除了可以傳入值、物件、陣列，也可以將另一個函式傳入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函式參數傳入函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params">name, a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">&#x27;你好&#x27;</span>，a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  fn(<span class="string">&#x27;小明&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fnB(callSomeone)</span><br></pre></td></tr></table></figure>

<h2 id="閉包"><a href="#閉包" class="headerlink" title="閉包"></a>閉包</h2><p>閉包為範圍鏈、記憶體空間、表達式以及函式等觀念總合的概念，重複執行函式時，其變數值就會累加上去。要利用閉包的概念前，先來複習一下函式還有怎樣的特性。</p>
<ul>
<li>範圍鏈</li>
<li>函式與提升</li>
<li>函式與記憶體空間</li>
</ul>
<h3 id="函式與範圍鏈"><a href="#函式與範圍鏈" class="headerlink" title="函式與範圍鏈"></a>函式與範圍鏈</h3><p>在函式中的變數，若沒有宣告，則往外層尋找直到全域，若全域也沒有，則報錯。</p>
<h4 id="靜態作用域"><a href="#靜態作用域" class="headerlink" title="靜態作用域"></a>靜態作用域</h4><p>跟在哪裡被呼叫無關，跟位置有關。<br>來看以下範例，函式的位置會影響最後的結果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  fnA()</span><br><span class="line">&#125;</span><br><span class="line">fnB() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// fnA()內本身沒有 a變數，則向外層找</span></span><br><span class="line"><span class="comment">// 它也不在 fnB()內，於是找到了全域物件中的變數 a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fnD</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  fnD()</span><br><span class="line">&#125;</span><br><span class="line">fnC() <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// fnD()本身沒有 a變數，則向外層找</span></span><br><span class="line"><span class="comment">// 在 fnC()找到已宣告的變數 a</span></span><br></pre></td></tr></table></figure>

<h4 id="動態作用域"><a href="#動態作用域" class="headerlink" title="動態作用域"></a>動態作用域</h4><p>跟在哪裡使用無關，跟在哪裡被呼叫有關，最常見的就是 <code>this</code> 的運用。</p>
<h3 id="函式與提升-Hoisting"><a href="#函式與提升-Hoisting" class="headerlink" title="函式與提升(Hoisting)"></a>函式與提升(Hoisting)</h3><p>在函式中，</p>
<ul>
<li>將自訂參數重新宣告不會有任何作用</li>
<li>函式中的函式，不會提升至外層</li>
<li>若在函式中不將變數宣告或者非自訂參數，則可能依據呼叫環境在全域物件中建立變數</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 將自訂參數重新宣告不會有任何作用</span></span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 賦予新值</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 若在裏頭插入函式，它不會提升到外層</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fnB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  fnB()</span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;我是函式&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &#x27;我是函式&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;我是函式&#x27;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// a is not defined </span></span><br><span class="line"><span class="comment">// 2，b未正式宣告且因為範圍鏈(向外層尋找)的關係，在全域物件中建立了變數</span></span><br></pre></td></tr></table></figure>

<h3 id="函式與記憶體空間"><a href="#函式與記憶體空間" class="headerlink" title="函式與記憶體空間"></a>函式與記憶體空間</h3><p>先看下面的例子，函式每次執行時，都會加 1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 1</span></span><br><span class="line">fn() <span class="comment">// 2</span></span><br><span class="line">fn() <span class="comment">// 3</span></span><br><span class="line">fn() <span class="comment">// 4</span></span><br><span class="line">fn() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>如果將變數 a，移動到函式內，重複執行函式時，就會因為記憶體空間被釋放掉，又重新宣告而無法累計。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  a += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 1</span></span><br><span class="line">fn() <span class="comment">// 1</span></span><br><span class="line">fn() <span class="comment">// 1</span></span><br><span class="line">fn() <span class="comment">// 1</span></span><br><span class="line">fn() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>接下來，改寫上述範例，假設今天去夜市套圈圈，老闆的每個籃子裡總共有五個圈圈，規則是每次只能丟一個圈圈。今天有兩個玩家，都另開新局，他們都能有五個圈圈可投。</p>
<ul>
<li>return 一個函式，此函式包含著變數，該變數會視為還須利用而不會被上層的函式釋放掉</li>
<li>分別宣告變數並賦予函式，函式內部所宣告的變數不會互相影響<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">game</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="number">5</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    times -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`圈圈剩餘 <span class="subst">$&#123;times&#125;</span> 個`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personA = game()</span><br><span class="line"><span class="built_in">console</span>.log(personA()) <span class="comment">// 圈圈剩餘 4個</span></span><br><span class="line"><span class="built_in">console</span>.log(personA()) <span class="comment">// 圈圈剩餘 3個</span></span><br><span class="line"><span class="built_in">console</span>.log(personA()) <span class="comment">// 圈圈剩餘 2個</span></span><br><span class="line"><span class="built_in">console</span>.log(personA()) <span class="comment">// 圈圈剩餘 1個</span></span><br><span class="line"><span class="built_in">console</span>.log(personA()) <span class="comment">// 圈圈剩餘 0個</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personB = game()</span><br><span class="line"><span class="built_in">console</span>.log(personB()) <span class="comment">// 圈圈剩餘 4個</span></span><br><span class="line"><span class="built_in">console</span>.log(personB()) <span class="comment">// 圈圈剩餘 3個</span></span><br><span class="line"><span class="built_in">console</span>.log(personB()) <span class="comment">// 圈圈剩餘 2個</span></span><br><span class="line"><span class="built_in">console</span>.log(personB()) <span class="comment">// 圈圈剩餘 1個</span></span><br><span class="line"><span class="built_in">console</span>.log(personB()) <span class="comment">// 圈圈剩餘 0個</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="閉包進階與函式工廠"><a href="#閉包進階與函式工廠" class="headerlink" title="閉包進階與函式工廠"></a>閉包進階與函式工廠</h3><p>這次老闆使用機器人自動丟五個圈圈出去，每次丟一個就紀錄一次剩餘多少個圈圈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">game</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="number">5</span></span><br><span class="line">  <span class="keyword">var</span> gameLog = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++)&#123;</span><br><span class="line">    times -= <span class="number">1</span></span><br><span class="line">    gameLog.push(<span class="string">`第 <span class="subst">$&#123;x+<span class="number">1</span>&#125;</span> 次丟出圈圈剩餘 <span class="subst">$&#123;times&#125;</span> 個`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> gameLog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personA = game()</span><br><span class="line"><span class="built_in">console</span>.log(personA)</span><br><span class="line"><span class="comment">// [&quot;第 1 次丟出圈圈剩餘 4 個&quot;, </span></span><br><span class="line"><span class="comment">// &quot;第 2 次丟出圈圈剩餘 3 個&quot;,</span></span><br><span class="line"><span class="comment">// &quot;第 3 次丟出圈圈剩餘 2 個&quot;, </span></span><br><span class="line"><span class="comment">// &quot;第 4 次丟出圈圈剩餘 1 個&quot;, </span></span><br><span class="line"><span class="comment">// &quot;第 5 次丟出圈圈剩餘 0 個&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="閉包進階的私有方法"><a href="#閉包進階的私有方法" class="headerlink" title="閉包進階的私有方法"></a>閉包進階的私有方法</h3><p>讓我們再度強化機器人的可用性，基礎次數五次，每丟一次就記錄一次到陣列中，利用閉包的原理，將函式 return一個物件。<br>但是，這台機器人卻有個地方無法正常顯示，該怎麼修復它呢?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">game</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="number">5</span></span><br><span class="line">  <span class="keyword">var</span> gameLog = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    log: gameLog, </span><br><span class="line">    nowTimes: <span class="string">`目前剩餘次數為 <span class="subst">$&#123;times&#125;</span> 次`</span>,</span><br><span class="line">    addTimes: <span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">      times += number</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`目前剩餘次數為 <span class="subst">$&#123;times&#125;</span> 次`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++)&#123;</span><br><span class="line">        times -= <span class="number">1</span></span><br><span class="line">        gameLog.push(<span class="string">`第 <span class="subst">$&#123;x+<span class="number">1</span>&#125;</span> 次丟出圈圈剩餘 <span class="subst">$&#123;times&#125;</span> 個`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;開始自動執行遊戲&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personA = game()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personA.addTimes(<span class="number">25</span>)) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(personA.nowTimes) <span class="comment">// 卻還是顯示 5次</span></span><br></pre></td></tr></table></figure>

<p>函式 <code>personA</code> return的物件，其包含許多函式與變數，而單純變數值卻無法修改? 我們來檢查看看，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 節錄 personA片段</span></span><br><span class="line"><span class="built_in">console</span>.log(personA) </span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   nowTimes: `目前剩餘次數為 5 次`,</span></span><br><span class="line"><span class="comment">//   addTimes: function(number)&#123;</span></span><br><span class="line"><span class="comment">//     times += number</span></span><br><span class="line"><span class="comment">//     return `目前剩餘次數為 $&#123;times&#125; 次`</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到有的直接變成字串，而待在函式裡的變數則維持變數的樣子，讓我們再回想閉包的原理，若該函式內的變數有需要用到，則記憶體空間不會被釋放掉，也就是說，屬性值為單純的變數，被使用後就釋放掉了，待在函式內的則不會。那麼，我們來修正機器人，將 <code>addTimes</code> 這個屬型值改為函式，這樣就能正確顯示了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">game</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> times = <span class="number">5</span></span><br><span class="line">  <span class="keyword">var</span> gameLog = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    log: gameLog, </span><br><span class="line">    nowTimes: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`目前剩餘次數為 <span class="subst">$&#123;times&#125;</span> 次`</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    addTimes: <span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">      times += number</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`目前剩餘次數為 <span class="subst">$&#123;times&#125;</span> 次`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++)&#123;</span><br><span class="line">        times -= <span class="number">1</span></span><br><span class="line">        gameLog.push(<span class="string">`第 <span class="subst">$&#123;x+<span class="number">1</span>&#125;</span> 次丟出圈圈剩餘 <span class="subst">$&#123;times&#125;</span> 個`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;開始自動執行遊戲&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personA = game()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personA.addTimes(<span class="number">25</span>)) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(personA.nowTimes()) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><blockquote>
<ol>
<li>六角學院 - JS核心篇</li>
<li><a href="https://ithelp.ithome.com.tw/articles/10200841">cythilya - 你懂 JavaScript 嗎？#4 型別（Types）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10191549">Kuro Hsu - 重新認識 JavaScript: Day 10 函式 Functions 的基本概念</a></li>
<li><a href="https://w3c.hexschool.com/blog/cb6e361">Ray - 有點長的淺談 JavaScript function 函式</a></li>
<li><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/">Huli - 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/">Huli - 所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10203387">OneJar - 你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍—變數的作用域(Scope) (1)</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
